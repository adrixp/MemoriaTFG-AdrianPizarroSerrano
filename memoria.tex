%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Plantilla de memoria en LaTeX para la ETSIT - Universidad Rey Juan Carlos
%%
%% Por Gregorio Robles <grex arroba gsyc.urjc.es>
%%     Grupo de Sistemas y Comunicaciones
%%     Escuela Técnica Superior de Ingenieros de Telecomunicación
%%     Universidad Rey Juan Carlos
%% (muchas ideas tomadas de Internet, colegas del GSyC, antiguos alumnos...
%%  etc. Muchas gracias a todos)
%%
%% La última versión de esta plantilla está siempre disponible en:
%%     https://github.com/gregoriorobles/plantilla-memoria
%%
%% Para obtener PDF, ejecuta en la shell:
%%   make
%% (las imágenes deben ir en PNG o JPG)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper, 12pt]{book}
%\usepackage[T1]{fontenc}

\usepackage[a4paper, left=2.5cm, right=2.5cm, top=3cm, bottom=3cm]{geometry}
\usepackage{times}
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel} % Comenta esta línea si tu memoria es en inglés
\usepackage{url}
%\usepackage[dvipdfm]{graphicx}
\usepackage{graphicx}
\usepackage{float}  %% H para posicionar figuras
\usepackage[nottoc, notlot, notlof, notindex]{tocbibind} %% Opciones de índice
\usepackage{latexsym}  %% Logo LaTeX
\usepackage[hidelinks]{hyperref}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}


\lstdefinelanguage{JavaScript}{
	keywords={break, case, catch, continue, debugger, default, delete, do, else, false, finally, for, function, if, in, instanceof, new, null, return, switch, this, throw, true, try, typeof, var, void, while, with, let, const, exports},
	morecomment=[l]{//},
	morecomment=[s]{/*}{*/},
	morestring=[b]',
	morestring=[b]",
	ndkeywords={class, export, boolean, throw, implements, import, this},
	keywordstyle=\color{blue}\bfseries,
	ndkeywordstyle=\color{darkgray}\bfseries,
	identifierstyle=\color{black},
	commentstyle=\color{purple}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	sensitive=true
}

\lstdefinelanguage{json}{
	basicstyle=\normalfont\ttfamily,
	numbers=left,
	numberstyle=\scriptsize,
	stepnumber=1,
	numbersep=8pt,
	showstringspaces=false,
	breaklines=true,
	frame=lines,
	backgroundcolor=\color{background},
	literate=
	*{0}{{{\color{numb}0}}}{1}
	{1}{{{\color{numb}1}}}{1}
	{2}{{{\color{numb}2}}}{1}
	{3}{{{\color{numb}3}}}{1}
	{4}{{{\color{numb}4}}}{1}
	{5}{{{\color{numb}5}}}{1}
	{6}{{{\color{numb}6}}}{1}
	{7}{{{\color{numb}7}}}{1}
	{8}{{{\color{numb}8}}}{1}
	{9}{{{\color{numb}9}}}{1}
	{:}{{{\color{punct}{:}}}}{1}
	{,}{{{\color{punct}{,}}}}{1}
	{\{}{{{\color{delim}{\{}}}}{1}
	{\}}{{{\color{delim}{\}}}}}{1}
	{[}{{{\color{delim}{[}}}}{1}
	{]}{{{\color{delim}{]}}}}{1},
}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}

\lstset{style=mystyle}

\title{Memoria del Proyecto}
\author{Nombre del autor}

\renewcommand{\baselinestretch}{1.5}  %% Interlineado

\begin{document}

\renewcommand{\refname}{Bibliografía}  %% Renombrando
\renewcommand{\appendixname}{Apéndice}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PORTADA

\begin{titlepage}
\begin{center}
\begin{tabular}[c]{c c}
%\includegraphics[bb=0 0 194 352, scale=0.25]{logo} &
\includegraphics[scale=0.25]{img/logo_vect.png} &
\begin{tabular}[b]{l}
\Huge
\textsf{UNIVERSIDAD} \\
\Huge
\textsf{REY JUAN CARLOS} \\
\end{tabular}
\\
\end{tabular}

\vspace{3cm}

\Large
GRADO EN INGENIERÍA EN TECNOLOGÍAS DE LA TELECOMUNICACIÓN

\vspace{0.4cm}

\large
Curso Académico 2018/2019

\vspace{0.8cm}

Trabajo Fin de Grado

\vspace{2.5cm}

\LARGE
VISUALIZACIÓN DE DATOS EN REALIDAD VIRTUAL

\vspace{4cm}

\large
Autor : Adrián Pizarro Serrano \\
Tutor : Dr. Jesús María González Barahona
\end{center}
\end{titlepage}

\newpage
\mbox{}
\thispagestyle{empty} % para que no se numere esta pagina


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Para firmar
\clearpage
\pagenumbering{gobble}
\chapter*{}

\vspace{-4cm}
\begin{center}
\LARGE
\textbf{Trabajo Fin de Grado}

\vspace{1cm}
\large
Visualización de Datos en Realidad Virtual

\vspace{1cm}
\large
\textbf{Autor :} Adrián Pizarro Serrano \\
\textbf{Tutor :} Dr. Jesús María González Barahona

\end{center}

\vspace{1cm}
La defensa del presente Proyecto Fin de Carrera se realizó el día \qquad$\;\,$ de \qquad\qquad\qquad\qquad \newline de 2019, siendo calificada por el siguiente tribunal:


\vspace{0.5cm}
\textbf{Presidente:}

\vspace{1.2cm}
\textbf{Secretario:}

\vspace{1.2cm}
\textbf{Vocal:}


\vspace{1.2cm}
y habiendo obtenido la siguiente calificación:

\vspace{1cm}
\textbf{Calificación:}


\vspace{1cm}
\begin{flushright}
Fuenlabrada, a \qquad$\;\,$ de \qquad\qquad\qquad\qquad de 2019
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Dedicatoria

\chapter*{}
\pagenumbering{Roman} % para comenzar la numeracion de paginas en numeros romanos
\begin{flushright}
\textit{Dedicado a \\
mi familia}
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Agradecimientos

\chapter*{Agradecimientos}
%\addcontentsline{toc}{chapter}{Agradecimientos} % si queremos que aparezca en el índice
\markboth{AGRADECIMIENTOS}{AGRADECIMIENTOS} % encabezado 

Aquí vienen los agradecimientos\ldots Aunque está bien acordarse de la pareja, no hay que olvidarse de dar las gracias a tu madre, que aunque a veces no lo parezca disfrutará tanto de tus logros como tú\ldots 
Además, la pareja quizás no sea para siempre, pero tu madre sí.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen

\chapter*{Resumen}
%\addcontentsline{toc}{chapter}{Resumen} % si queremos que aparezca en el índice
\markboth{RESUMEN}{RESUMEN} % encabezado

Aquí viene un resumen del proyecto. Ha de constar de tres o cuatro párrafos, donde se presente de manera clara y concisa de qué va el proyecto. 
Han de quedar respondidas las siguientes preguntas:

\begin{itemize}
  \item ¿De qué va este proyecto? ¿Cuál es su objetivo principal?
  \item ¿Cómo se ha realizado? ¿Qué tecnologías están involucradas?
  \item ¿En qué contexto se ha realizado el proyecto? ¿Es un proyecto
dentro de un marco general?
\end{itemize}

Lo mejor es escribir el resumen al final.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen en inglés

\chapter*{Summary}
%\addcontentsline{toc}{chapter}{Summary} % si queremos que aparezca en el índice
\markboth{SUMMARY}{SUMMARY} % encabezado

Here comes a translation of the ``Resumen'' into English. Please, double check it for correct grammar and spelling.
As it is the translation of the ``Resumen'', which is supposed to be written at the end, this as well should be filled out
just before submitting.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen en inglés

\chapter*{Acrónimos}
%\addcontentsline{toc}{chapter}{Acrónimos} % si queremos que aparezca en el índice
\markboth{Acrónimos}{Acrónimos} % encabezado

\textbf{API:} Application Programming Interface

\textbf{HTML:} HyperText Markup Language

\textbf{HTTP:} HyperText Transfer Protocol

\textbf{JSON:} JavaScript Object Notation

\textbf{XML:} eXtensible Markup Language

\textbf{JS:} JavaScript

\textbf{3D:} Tres Dimensiones

\textbf{VR:} Virtual Reality

\textbf{DOM:} Document Object Model

\textbf{AJAX:} Asynchronous JavaScript And XML

\textbf{ES6:} ECMAScript 6

\textbf{IDE:} Integrated Development Environment

\textbf{SVN:} Subversion

\textbf{RAM:} Random Access Memory

\textbf{GPU:} Graphics Processing Unit

\textbf{FPS:} Frame Per Second


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ÍNDICES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Las buenas noticias es que los índices se generan automáticamente.
% Lo único que tienes que hacer es elegir cuáles quieren que se generen,
% y comentar/descomentar esa instrucción de LaTeX.

%%%% Índice de contenidos
\tableofcontents 
%%%% Índice de figuras
\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de figuras} % para que aparezca en el indice de contenidos
\listoffigures % indice de figuras
%%%% Índice de tablas
%\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de tablas} % para que aparezca en el indice de contenidos
%\listoftables % indice de tablas


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INTRODUCCIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Introducción}
\label{sec:intro} % etiqueta para poder referenciar luego en el texto con ~\ref{sec:intro}
\pagenumbering{arabic} % para empezar la numeración de página con números

Este proyecto trata sobre la representación de datos en tres dimensiones (a partir de ahora 3D) en un navegador web utilizando como base el {\textit{framework}} A-Frame\footnote{\url{https://aframe.io/}}. Este {\textit{framework}} nace a su vez a partir de la librería Three.js\footnote{\url{https://threejs.org/}} utilizada para mostrar gráficos animados en 3D.

El objetivo principal es crear una librería capaz de visualizar datos con distintos tipos de gráficos, fácilmente escalable, mantenible y sencilla de utilizar. Además, como objetivos más específicos, podrá ser usada en cualquier navegador y dispositivo de realidad virtual.

A continuación se describe el contexto, motivación, la estructura de esta memoria y la disponibilidad del software.

\section{Contexto}
\label{sec:contexto}

Hoy en día, prácticamente todo negocio se lleva a cabo o se promociona a través de Internet. La comunicación y la rentabilidad empresarial han mejorado enormemente gracias a la llegada de este fenómeno y de su mano surge el desarrollo web, el cual es uno de los mayores creadores de nuevos puestos de trabajo. 

Para todo este paradigma surgen, casi a diario, nuevos {\textit{frameworks}} para conseguir una mayor eficiencia y estandarización a la hora de crear páginas webs.

Cabe destacar que, a nivel empresarial, es necesario un estudio exhaustivo así como una mejor visualización, tratamiento y explotación de los datos. Para ello han surgido infinidad de librerías a nuestra disposición tales como D3.js\footnote{\url{https://d3js.org/}}, amcharts\footnote{\url{https://www.amcharts.com/}}, highcharts\footnote{\url{https://www.highcharts.com/}}, etc. 

Por otro lado, con el nacimiento de Canvas 3D en 2006 y su posterior evolución en WebGL se abre la puerta a la implementación de visualizaciones 3D en páginas webs. Como veremos más adelante, WebGL nos proporciona un API en javascript para renderizar visualizaciones 2D y 3D sobre HTML.

Paralelamente, nace el motor gráfico Unity el cual también ha ayudado a impulsar la fama y utilización de componentes 3D en múltiples plataformas. Ha sentado varias bases y conceptos reutilizados en muchas otras plataformas tales como el concepto de escena, cámaras, materiales, luces, sombras, formas geométricas y parámetros para cada componente.

Más tarde, y concerniente a este proyecto, nace Three.js como librería javascript basada en WebGL para crear y mostrar visualizaciones 3D. Esta librería ya nos proporciona todas las especificaciones necesarias para trabajar con escenas, efectos, animaciones, cámaras, etc. Para un uso más sencillo y estándar de esta librería y para su adaptación a la realidad Virtual nace A-frame en 2015. Gracias a esta última librería podemos utilizar todos nuestras escenas 3D y representarlas en lo que conocemos como WebVR, la cual es una interfaz que nos provee del soporte necesario para visualizar todo este contenido HTML 3D en un aparato de realidad virtual (Oculus Rift, HTC Vive y Google Cardboard) o un navegador.

Finalmente me gustaría hacer una mención especial a toda la comunidad que hay detrás de todas estas plataformas. Sin su aportación diaria, intercambio de conocimiento y ayuda nada de esto sería posible.

La unión de estos dos mundos, representación de datos y la llegada de visualizaciones 3D en navegadores web, nos lleva a nuestro siguiente apartado la motivación.

\section{Motivación}
\label{sec:motivacion}

Muchas veces se escucha la frase atribuida al filósofo inglés Francis Bacon ``La información es poder'', la cual es cierta, pero sin una correcta interpretación de la misma podemos caer en el caso de la desinformación. Como se menciona en el apartado anterior la visualización y explotación de datos es un campo en auge del cual se requiere mucha ingeniería para poder sacarle partido. Es un campo apasionante, lleno de retos, con muchas salidas laborales y en constante evolución.

Hasta ahora, tenemos infinidad de librerías para representar datos en 2D pero ¿Qué ocurre con la llegada del 3D a nuestros navegadores? ¿Existen librerías para visualizar datos utilizando realidad virtual o realidad aumentada? Lo cierto es que estas preguntas nos llevan a una de las motivaciones principales de este proyecto. Este mundo es relativamente nuevo y hasta ahora se ha apostado más por realizar visualizaciones complejas en 3D o videojuegos. Por lo que la representación de datos en 3D es un nicho aun por explotar.

Este último punto ha sido muy motivador para realizar una de las primeras librerías capaz de visualizar datos en 3D tanto en un navegador como en un dispositivo de realidad virtual. Además, la intención de este proyecto es que sea escalable, mantenible y el resto de la comunidad pueda contribuir a su uso y desarrollo.

Respecto a la motivación personal podemos decir que se ha pasado por distintas fases. En primer lugar, hubo un intento fallido de realizar una aplicación de posible utilidad médica. Siempre se puede interpretar como poner excusas, pero el tiempo, obligaciones y el querer dedicar tu tiempo libre a otros menesteres son factores que impidieron la consecución de este primer proyecto el cual, a pesar de todo, era muy interesante. Todo esto llevó a volver a comenzar con una búsqueda exhaustiva y motivadora donde por suerte pude contactar con Jesús, tutor del proyecto, el cual me ofreció toda la ayuda y un trabajo de fin de grado por el cual no me importara dedicar todo el tiempo libre posible.

Es así como gracias a todos estos factores se ha podido finalizar este proyecto y escritura de esta memoria. De la cual procedemos a describir su estructura en la siguiente sección.

\section{Estructura de la memoria}
\label{sec:estructura}

En esta sección se describe la estructura de la memoria para una mejor compresión de la misma:

\begin{itemize}
  \item En el primer capítulo se hace una breve introducción al proyecto. Describiremos el marco y contexto del trabajo para un mejor aterrizaje del lector. Acto seguido se habla de la motivación del proyecto tanto a nivel personal como profesional. Por último se describe brevemente la estructura de la memoria.
  
  \item En el capítulo 2 se muestran los objetivos del proyecto. Se comienza hablando del objetivo principal que perseguimos con este trabajo. Acto seguido, pasaremos a los específicos donde se profundizará y se ampliará los conceptos tratados en el objetivo principal. Además en este apartado se hará una descripción de la planificación temporal que se ha seguido para llevar a cabo este proyecto 
  
  \item A continuación se presenta el estado del arte. Aquí haremos un repaso así como una breve descripción de todas las tecnologías que se han utilizado.
  
  \item En el cuarto capítulo se desarrolla el diseño e implementación. Se entrará al detalle de como está construida la aplicación, su arquitectura y sus distintos componentes.
  
  \item En este quinto capítulo, Resultados, se realiza un análisis del funcionamiento y rendimiento de esta aplicación. Además se podrá ver un amplio abanico de casos de uso donde se verán los resultados y capacidades del proyecto.
   
  \item Por último, tendremos las conclusiones. Aquí se presentará un resumen de los distintos conceptos aprendidos y aplicados. Podremos ver si se han alcanzado los objetivos propuestos. Además se expondrán líneas futuras de investigación y mejora de esta aplicación.
\end{itemize}

\section{Disponibilidad del Software}
\label{sec:disponibilidad-software}

Para poder consultar y mantener el proyecto se ha creado un repositorio de software en el portal de GitHub. Este proyecto de software libre cuenta con una licencia de Apache 2.0. Todos los aportes a lo largo del tiempo así como las incidencias se pueden consultar en:
\vspace{5mm}

\url{https://github.com/adrixp/aframe-charts-component}

\vspace{5mm}
Además esta librería cuenta con una página web donde podemos ver todos los casos de uso. También se tiene un enlace directo al API para ver todos los parámetros disponibles, y por cada visualización el código utilizado. Se puede acceder a través del siguiente enlace:

\vspace{5mm}

\url{https://adrixp.github.io/aframe-charts-component/}

\vspace{5mm}

Por último, se ha publicado la librería en el sistema de gestión de paquetes (npm). Para facilitar su distribución y poder ser importado por un servidor nodejs en cualquier momento:

\vspace{5mm}

\url{https://www.npmjs.com/package/aframe-charts-component/}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OBJETIVOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage % empezamos en página impar
\chapter{Objetivos} % título del capítulo (se muestra)
\label{chap:objetivos} % identificador del capítulo (no se muestra, es para poder referenciarlo)

\section{Objetivo general} % título de sección (se muestra)
\label{sec:objetivo-general} % identificador de sección (no se muestra, es para poder referenciarla)

Mi trabajo fin de grado consiste en crear una librería para la visualización de datos en 3D compatible con cualquier navegador. La cual además pueda ser usada en un dispositivo de realidad virtual.

\section{Objetivos específicos}
\label{sec:objetivos-especificos}

En este apartado se realiza una breve descripción de los objetivos específicos.

\begin{enumerate}
		
	\item La librería debe proporcionar varios tipos de visualizaciones. Deberá implementar al menos cinco tipos de visualización tales como gráfico de burbujas, de tarta, de barras, de cilindros o tarta en forma de rosquilla.
	
	\item Se debe permitir una gran cantidad de parámetros. Por ejemplo, la posición, color, longitud y separación entre las marcas de medición de los ejes. Permitir que los ejes puedan ser negativos o estén en forma de rejilla para dos o más dimensiones. Poder configurar tamaño y color de una legenda, un pop-up o ambas.
	
	\item La librería debe ser capaz de añadir una leyenda a un gráfico y/o un pop-up para una mejor interpretación de los datos. Con ello se persigue obtener más información y facilitar la lectura de datos.
	
	\item La librería debe proporcionar una herramienta para filtrar o seleccionar distintas fuentes de datos. Además podrán refrescar las visualizaciones dinámicamente.
	
	\item Debe ser capaz de interpretar ficheros con formato JSON (JavaScript Object Notation) y lanzar una excepción si no fuera capaz de leer el archivo correctamente.
	
	\item El rendimiento es un factor clave que se desea cuidar en este proyecto. Por ello, esta librería debe mostrar un buen comportamiento cargando grandes volúmenes de datos. Se debe comprobar que es capaz de mostrar visualizaciones con una gran cantidad de datos 
	
	\item Se debe poder utilizar en cualquier navegador sin necesidad de instalar ningún plugin. Además se debe poder utilizar y visualizar en dispositivos de realidad virtual como las Oculus Rift.
	
	\item La librería se debe distribuir y poner al servicio de la comunidad. Se debe dar fácil acceso y ser subida a un repositorio de código donde se puedan recibir sugerencias para implementar y resolver posibles incidencias.
	
	\item Debe ser fácilmente escalable, es decir, deberá estar desarrollada de tal manera que sea sencillo implementar nuevos desarrollos o modificaciones en el código.
	
	\item Un objetivo importante es que el código deberá ser mantenible tanto por su autor como por la comunidad. Se debe publicar dicho software en una plataforma donde, como se menciona anteriormente, se pueda contribuir a resolver incidencias y mantener actualizado de manera sencilla las versiones de los framework y librerías que utilizará el proyecto.
	
	\item Aprender Webpack para empaquetar y distribuir nuestra librería.
	
	\item Aprender el framework de A-frame. Se debe estudiar en profundidad su documentación y estándares para un uso óptimo de la misma. Esta librería de realidad virtual está basada en Three.js por lo que también se deberá realizar un estudio de la misma.
	
	\item Crear una web con ejemplos de uso de la librería.
	
	\item Crear el proyecto con Angle. Una herramienta hecha por los creadores de Aframe para comenzar nuestro componente con un arquetipo que sigue los estándares de Aframe
	
	\item Una vez creado el proyecto siguiendo los estándares y después de realizar los primeros avances se deberá publicar nuestro proyecto en el registry de Aframe donde aparecen todos los componentes de la comunidad de A-frame. Esto proporcionará visibilidad al proyecto pudiendo salir en el blog oficial llamado Week of a- Frame 

	\item Se deberá cuidar y refactorizar el código para una lectura sencilla del mismo siguiendo distintas directrices que podemos encontrar en el libro Clean Code~\cite{martin:_cleancode}.
	
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ESTADO DEL ARTE %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Estado del arte}

En este capítulo se describirán las tecnologías que se utilizan en este trabajo. Se hará un repaso tanto de los lenguajes básicos de programación web utilizados, el servidor web y las herramientas para la paquetización y distribución de la librería.

También se mencionarán las librerías de realidad virtual y los motores en los que estas se apoyan, los cuales facilitan enormemente el trabajo de desarrollo.

\section{HTML} 
\label{sec:htmlseccion}
\begin{center}
\includegraphics[scale=0.30]{img/html.png}
\end{center}

En 1993 se lanza este lenguaje de marcado como herramienta principal para construir páginas web. Define una estructura básica a partir de etiquetas que son interpretadas por los navegadores. El encargado de su mantenimiento y estandarización es el Consorcio de la {\textit{World Wide Web}} (W3C).

Mas adelante, en 2014, se lanza la quinta versión de HTML comúnmente conocida como HTML5~\cite{pilgrim:_htmluprun}. En esta nueva versión se incluyen nuevos elementos como la cabecera \textless header\textgreater, el pie \textless footer\textgreater\space y la sección \textless section\textgreater\space entre otros. Además se añaden elementos gráficos como Canvas, una superficie bidimensional para dibujar mediante Javascript, y svg para gráficos vectoriales.

Por otro lado también se incluyen nuevos atributos y etiquetas para elementos multimedia como audio y video. Finalmente cabe destacar que el nuevo API nos provee de herramientas para la geolocalización, {\textit{drag and drop}}, almacenamiento local, caché, etc.


\section{JavaScript} 
\label{sec:jsseccion}
\begin{center}
\includegraphics[scale=0.30]{img/js.png}
\end{center}

Para dotar de funcionalidad y dinamismo a las páginas web, que como mencionamos anteriormente utilizan el lenguaje de marcado HTML, tenemos JavaScript~\cite{flanagan:_jsguide}. En 1995 nace este lenguaje orientado a objetos, el cual tiene tipado dinámico y utiliza prototipos en vez de clases para el uso de herencia.

El estándar que sigue este lenguaje actualmente es ECMAScript Todos los navegadores incluyen una implementación de dicho estándar. En este proyecto utilizamos la última versión publicada en 2015 ECMAScript 6 (ES6).

Este lenguaje puede ser utilizado tanto en el lado del cliente como en el lado del servidor como se puede ver más adelante. En el lado del cliente se nos ofrece infinidad de posibilidades para manipular el DOM.

Por último cabe destacar la infinidad de {\textit{frameworks}} que surgen día a día en la actualidad. Un {\textit{framework}} define el diseño completo de una aplicación web y nos facilita el uso de patrones de diseño~\cite{gamma:_designpatterns} como, por ejemplo, el Modelo Vista Controlador (MVC). Hoy en día tenemos a Angular.js\footnote{\url{https://angularjs.org/}}, React\footnote{\url{https://reactjs.org/}} y Vue.js\footnote{\url{https://vuejs.org/}} como los {\textit{frameworks}} más populares

\section{JSON} 
\label{sec:jsonseccion}

Como alternativa a XML nace JSON. Es un formato de texto para la distribución de datos o puede ser usado como un objeto Javascript que tiene distinta información, como vemos en la Figura~\ref{fig:json},  debido a su gran versatilidad. Es un formato muy sencillo de leer y de {\textit{parsear}}, es decir, de obtener su información.

\begin{figure}
	\centering
	\includegraphics[width=9cm, keepaspectratio]{img/json}
	\caption{Ejemplo JSON básico}
	\label{fig:json}
\end{figure}

Los tipos de datos que soporta JSON son: números, texto, {\textit{booleanos}}, {\textit{arrays}} y objetos Javascript formados por tuplas clave-valor. Y en comparación con XML tiene un mayor soporte y herramientas para su uso.
En este proyecto se va a utilizar JSON como formato de entrada de datos. Además, se puede ver en los siguientes puntos que para resolver las dependencias de nuestro proyecto y dar una descripción general del mismo se utiliza un fichero de datos llamado {\textit{package.json}}.

\section{NodeJS} 
\label{sec:nodeseccion}
\begin{center}
\includegraphics[scale=0.30]{img/node.png}
\end{center}

NodeJs~\cite{pasquali:_nodejs} es un servidor web desarrollado en C++ en el año 2009. Esta plataforma nos permite desarrollar en el lado del servidor con el lenguaje Javascript y el estándar ES6.

Es un servidor cuyas características principales son que es {\textit{monohilo}} y asíncrono. Como vemos en la Figura~\ref{fig:nodeserver}, tenemos un único hilo donde por cada petición se delega el trabajo y se da respuesta de  manera asíncrona, es decir, no es bloqueante y se ejecutará de manera concurrente recibiendo dichas respuestas mediante funciones {\textit{callback}}.

\begin{figure}
	\centering
	\includegraphics[width=12cm, keepaspectratio]{img/nodeServer}
	\caption{Arquitectura NodeJs}
	\label{fig:nodeserver}
\end{figure}

Como se menciona anteriormente, el archivo package.json es el corazón del sistema Node.js. Es el archivo de manifiesto de cualquier proyecto con Node.js y contiene los metadatos del proyecto. Además, en la siguiente sección, se podrá ver como el gestor de paquetes de node (NPM) utiliza este fichero para obtener información y descargar las dependencias.

Cabe destacar que NodeJs se utiliza como servidor web en infinidad de compañías y tiene una fuerte comunidad detrás apoyando su desarrollo.

\section{npm} 
\label{sec:npmseccion}
\begin{center}
	\includegraphics[scale=0.30]{img/npm.png}
\end{center}
Como gestor de paquetes, módulos y dependencias de NodeJs nace en 2014 NPM. Es instalado automáticamente con cualquier versión de NodeJs a partir de la 0.6.3. Las instrucciones se ejecutan por línea de comandos y cualquier usuario puede consumir los paquetes subidos a esta plataforma de manera versionada.

Para este proyecto se ha creado un repositorio de npm para poder distribuir nuestra propia librería como dependencia y poder ser usada de manera ágil\footnote{\url{https://www.npmjs.com/package/aframe-charts-component}}. Es necesario registrarse en la plataforma para poder publicar.

Gracias a esta herramienta se facilita el poder crear, compartir, reutilizar y contribuir a los distintos módulos desarrollados por la comunidad.

\section{Budo} 
\label{sec:budoseccion}

Budo es una herramienta que nos permite desarrollar en el servidor con integración {\textit{LiveReload}}. Esto nos permite que cualquier cambio que realicemos en el servidor se vea reflejado instantáneamente sin necesidad de recargar toda la instancia. Para ello, Budo utiliza otro paquete npm llamado {\textit{broserfy}} que nos permite exportar módulos y dependencias en el cliente.

En este proyecto ha sido muy útil esta herramienta ya que ha facilitado y agilizado el desarrollo. Este paquete está disponible en el repositorio de npm

\section{HighlightJs} 
\label{sec:highlightseccion}

Esta librería es utilizada para representar código de manera legible en una página web. Nos permite mostrar cualquier lenguaje de programación resaltando las palabras clave como si estuviéramos utilizando un IDE (Entorno de desarrollo) o un editor de texto que tuviera esta funcionalidad.

Como parámetros de entrada, esta librería, acepta nombre del lenguaje de programación, un alias o directamente código. Además cuenta con la posibilidad de resaltar texto a pesar de que haya errores de sintaxis en el código. Cuenta con detección automática del lenguaje de programación e incluso se tiene la posibilidad de incluir múltiples lenguajes en una misma instancia. 

Los usuarios cuentan con la posibilidad de añadir nuevos lenguajes de programación según la necesidad y proveer soporte de los mismos. Actualmente cuenta con soporte para 185 lenguajes de programación y 85 estilos.

En este proyecto, HighlightJs ha sido utilizado para elaborar el manual de usuario\footnote{\url{https://adrixp.github.io/aframe-charts-component/examples/bubbleChart/code.html}} facilitando así la lectura de código y pudiendo reutilizar este código de manera más clara como vemos en la Figura~\ref{fig:highlightexample}

\begin{figure}
	\centering
	\includegraphics[width=12cm, keepaspectratio]{img/highlightexample}
	\caption{Ejemplo HighlightJs}
	\label{fig:highlightexample}
\end{figure}

\section{Webpack} 
\label{sec:webpackseccion}
\begin{center}
	\includegraphics[scale=0.50]{img/webpack.png}
\end{center}

Webpack es un empaquetador de módulos estáticos. En la programación modular, los desarrolladores particionan su código en pequeños bloques que cumplen una funcionalidad concreta, y a estos se le llama módulos. Gracias a ellos, es trivial verificar, corregir y probar un programa.

El problema que nos podemos encontrar es que, si dividimos nuestro programa en muchos módulos, podemos tener problemas de escalabilidad debido a la gran cantidad de paquetes o {\textit{scripts}} que el navegador necesita descargar. Esto puede provocar, lo que comúnmente llamamos e redes, un {\textit{cuello de botella}}~\cite{littlejohn:_comnetwork}.

Por otro lado podríamos tener un único {\textit{script}} que contenga todo el código. Pero esto nos puede llevar a problemas de alcance, tamaño, legibilidad y mantenibilidad.

Resolviendo esta problemática nace Webpack. El cual nos permite escribir módulos soportando todos los formatos y además gestionar recursos. Como vemos en la Figura~\ref{fig:whatswebpack} es una herramienta que nos permite empaquetar aplicaciones {\textit{JavaScript}} modernas que contengan módulos, imágenes, fuentes, hojas de estilos.

Por último cabe destacar que Webpack se preocupa por el rendimiento y los tiempos de carga. Siempre está mejorando o agregando nuevas funciones, como la carga asíncrona, para ofrecer la mejor experiencia posible para el proyecto y los usuarios.

\begin{figure}
	\centering
	\includegraphics[width=12cm, keepaspectratio]{img/whatswebpack}
	\caption{Qué es Webpack}
	\label{fig:whatswebpack}
\end{figure}

\section{Git} 
\label{sec:gitseccion}
\begin{center}
	\includegraphics[scale=0.30]{img/git.png}
\end{center}

Como herramienta de control de versiones, en este proyecto se utiliza Git~\cite{chacon:_progit}. Este {\textit{software}} fue diseñado por Linus Torvalds (Creador del {\textit{kernel}} de {\textit{Linux}}) en 2005, cuyo propósito era crear un sistema capaz de llevar el registro de cambios en archivos de un ordenador y coordinar el trabajo que realicen varias personas simultáneamente sobre dichos ficheros.

Este software está pensado para ser utilizado de manera distribuida manteniendo un registro tanto en la computadora local como en un servidor. De esta forma cada usuario tiene una copia de los ficheros que valida contra el servidor si ha habido cambios o quisiera registrar alguno.

Gracias a esto, se consigue un gran apoyo al desarrollo mediante la rapidez para gestionar ramas y mezclado de las mismas. De hecho, en la mayoría de proyectos de desarrollo Git ha desbancado a SVN como principal controlador de versiones.

\section{Realidad Virtual} 
\label{sec:vrseccion}

Entendemos por realidad virtual~\cite{grigore:_vrtech} aquella tecnología que a través de uno o varios dispositivos nos puede general la sensación de realidad en un escenario artificial creado de manera digital. Este término nace a finales de la década de 1980 y originariamente describe cómo una persona interacciona con un entorno tridimensional (3D) artificial.

En la Figura~\ref{fig:oculus} podemos ver un ejemplo de dispositivo de realidad virtual. Por lo general, cuentan con un primer aparato que se coloca en la cabeza a la altura de los ojos para realizar una inmersión en el mundo virtual y abstraerse de la realidad convencional. Además, como vemos en la imagen, estos dispositivos cuentan con unos mandos para moverse o realizar acciones dentro de este mundo virtual.

Desde un inicio, esta tecnología ha estado orientada a la industria de los videojuegos. Pero no ha tardado en expandirse y tener aplicación en el mundo de la medicina, enseñanza, industria y turismo.

\begin{figure}
	\centering
	\includegraphics[width=12cm, keepaspectratio]{img/oculus}
	\caption{Dispositivo de Realidad Virtual}
	\label{fig:oculus}
\end{figure}

\section{OpenGL} 
\label{sec:webglseccion}
\begin{center}
	\includegraphics[scale=0.30]{img/opengl.png}
\end{center}

OpenGL es una librería de gráficos de código abierto cuyo lanzamiento inicial fue en el año 1994. Define un API multilenguaje y multiplataforma para producir aplicaciones que rendericen gráficos en 2D y 3D. Esta interfaz cuenta con mas de 250 funciones para dibujar escenas tridimensionales a partir de primitivas más simples bidimensionales.

Sus aplicaciones a día de hoy va desde simuladores de vuelo hasta el desarrollo de videojuegos con una creciente comunidad que impulsa este fenómeno. Además está pensado para conseguir una mayor abstracción sobre la complejidad de interactuar con el hardware de la tarjeta gráfica ofreciendo un API único y uniforme.

En la  Figura~\ref{fig:openglshader} tenemos un ejemplo de como a partir de primitivas simples como vértices podemos ir creando distintas formas como triángulos. Cada uno de estos vértices almacena ciertos atributos como por ejemplo las coordenadas.

Por último la tarjeta gráfica procesa cada uno de estos vértices de manera individual y aplica la transformación necesaria para proyectar estos vértices en el mundo 3D en nuestra pantalla 2D. Una vez transformados lo vértices de entrada se formarán los triángulos, líneas o puntos mencionadas anteriormente como primitivas simples.

Un último paso, introducido recientemente, es el de aplicar el sombreado geométrico o {\textit{shader}}.
\begin{figure}
	\centering
	\includegraphics[width=12cm, keepaspectratio]{img/openglshader}
	\caption{Ejemplo de Shader OpenGL}
	\label{fig:openglshader}
\end{figure}

\section{WebVR} 
\label{sec:webvrseccion}

WebVR es una API experimental escrito en Javascript en 2006. Fue iniciado como prototipo de Canvas3D por Vladimir Vuki?evi? en Mozilla. Este API proporciona soporte para dispositivos de realidad virtual tales como Oculus Rift, HTC Vive o Google Cardboard, en un navegador de web.

Sus principales objetivos son detectar de manera automática dispositivos de realidad virtual disponibles y obtener sus características principales, como la posición y orientación del dispositivo, para mostrar imágenes con una latencia aceptable.

Esta tecnología tiene una primera versión finalizada en 2017 donde principales compañías como Mozilla, Google y ahora Microsoft dan soporte y mantenimiento.

La API WebVR expone ciertas interfaces que permiten a las aplicaciones web incluir contenido de realidad virtual. Para ello se hace uso de WebGL, descrito en el siguiente apartado, como motor para gráficos 3D. Además permite obtener las configuraciones necesarios para la cámara y los dispositivos controladores (por ejemplo, un mando o el punto de vista).

\section{WebGL} 
\label{sec:webglseccion}
\begin{center}
	\includegraphics[scale=0.30]{img/webgl.png}
\end{center}

WebGL~\cite{danchilla:_webgl} o {\textit{Web Graphics Library}} es un estándar que define una API escrito en JavaScript y que implementa OpenGl  para la generación de gráficos en 3D en el navegador web. No es necesaria la instalación de un complemento o {\textit{plugin}} para los navegadores, debido a que actualmente tanto las versiones para móvil como las de escritorio cuentan con soporte OpenGL 2.0. 

Esta tecnología nace a raíz del WebVR mencionado en el apartado anterior y es en 2009 cuando se consolida como grupo de trabajo. A raíz de ello en marzo de 2011 se lanza la primera versión oficial.

La primera versión (1.0) de WebGL está basado en OpenGL 2.0 y proporciona una API para gráficos 3D. Esta, utiliza el elemento HTML5 llamado canvas o lienzo al que se accede mediante el Document Object Model (DOM). Para ello se debe definir una región dentro de nuestro HTML donde se representará la escena 3D. Solo es posible crear esta región en los navegadores web que admiten HTML5. Al ser parte del DOM nos permite interactuar de forma dinámica con otros elementos de la página.

WebGL 2.0 está basado en OpenGL 3.0 y garantiza disponibilidad de muchas extensiones opcionales de WebGL 1.0 y presenta nuevas APIs que facilitan el desarrollo.

WebGL está integrado completamente en todos los estándares web del navegador, permitiendo la aceleración de la GPU y el procesamiento de imágenes y efectos. Esta gestión automática de memoria RAM o virtual se proporciona mediante el lenguaje JavaScript.

\section{Three.js} 
\label{sec:threejsseccion}
\begin{center}
	\includegraphics[scale=0.30]{img/threejs.png}
\end{center}

Three.js\footnote{\url{https://threejs.org}} es una librería escrita en JavaScript para mostrar contenido 3D en páginas web. Nos provee la capacidad de renderizar escenas, modelos, sonido, vídeos, luces, sombras, animaciones, partículas y muchos otros tipos de visualizaciones.

No debemos confundir Three.js con WebGL. WebGL es un sistema de bajo nivel con el que podemos dibujar primitivas simples como puntos, líneas y triángulos. Three.js utiliza este motor a bajo nivel y nos permite abstraernos de su complejidad teniendo ya disponibles ciertas interfaces como escenas, luces, materiales, etc mencionadas anteriormente.

Al igual que WebGL, se utiliza el elemento canvas de HTML5 para comenzar creado una escena. En la  Figura~\ref{fig:threejscene} podemos ver la arquitectura general de como se compone dicha escena. Por un lado tenemos la figura geométrica compuesta por vértices y superficies. Esta figura geométrica puede se le puede añadir un material que está compuesta por una o varias imágenes que a su vez componen lo que conocemos por textura. Si sumamos esta figura geométrica y su material obtenemos lo que denominamos una malla. La malla, las luces y la cámara componen nuestra escena 3D.

\begin{figure}
	\centering
	\includegraphics[height=10cm,width=12cm, keepaspectratio]{img/threejscene}
	\caption{Escena Three.js}
	\label{fig:threejscene}
\end{figure}

Por último, de manera transparente para el desarrollador, Three.js llama al renderizador de WebGL para representar nuestra escena que se podrá visualizar en cualquier navegador web.

Para comprender mejor el funcionamiento o para que sirve una cámara en una escena 3D tenemos la Figura~\ref{fig:frustum}. La cámara es un punto de perspectiva desde donde se visualiza la escena 3D. En Three.js tenemos cuatro parámetros básicos para definir una cámara:

\begin{figure}
	\centering
	\includegraphics[height=7cm,width=10cm, keepaspectratio]{img/frustum}
	\caption{Ejemplo de cámara. Forma geométrica ''{\textit{frustum}}''}
	\label{fig:frustum}
\end{figure}

\begin{itemize}
	\item El ''fov'' es la abreviatura de {\textit{field of view}} o campo de visión. Es el ángulo de visuón de la cámara y se utilizan grados como medida.
	
	\item El segundo parámetro es el ''aspect''. El cual define el aspecto de visualización del lienzo o el ratio de píxeles. Por ejemplo un canvas de 400 píxeles de ancho por 200 de alto, tendría un ''aspect'' de dos.
	
	\item Por último tenemos los parámetro ''far'' y ''near'' que definen la distancia de lo que vamos a poder visualizar en la escena. Si algún objeto quedara fuera de este rango no se visualizará.
\end{itemize}


Estos cuatro ajustes definen un ''{\textit{frustum}}'', es decir, el nombre de una forma 3D en forma de pirámide con la punta cortada. Al fin y al cabo esta definición es la que utiliza la cámara para visualizar la escena.


\section{A-Frame} 
\label{sec:aframeseccion}
\begin{center}
	\includegraphics[scale=0.30]{img/aframe.jpg}
\end{center}

A-Frame\footnote{\url{https://aframe.io/}} es un {\textit{framework web}} que permite construir experiencias de realidad virtual en el navegador. Gracias a su interfaz de entidad-componente podemos visualizar WebVR en cualquier dispositivo de realidad virtual como las HTC Vive, Oculus Rift, Daydream o Samsung GearVR así como en navegadores de escritorio y móvil. Además puede ser incluso usado para realidad aumentada.

A-Frame no es solo un creador de escenas en 3D o un lenguaje de marcado. Su motor está apoyado en el {\textit{framework web}} entidad-componente, proveyendo una estructura declarativa, extensible y componible de Three.js. A-Frame nos provee un nivel más de abstracción, facilitando incluso más aún el comienzo para desarrollar en 3D que Three.js.

Esta librería, estuvo originalmente concebida por Mozilla y ahora mantenida por los co-creadores de A-Frame y Supermedium\footnote{\url{https://supermedium.com/}} el cual es un navegador web puramente diseñado para WebVR y usado con dispositivos de realidad virtual. Este proyecto de código libre cuenta con una de las mayores comunidades de Realidad Virtual.

Entre sus mayores características encontramos:

\begin{itemize}
	\item A-Frame provee de un arquetipo 3D, configuración para VR y los controles predeterminados. Sin necesidad de instalación o compilación, únicamente es necesario importar la librería con la etiqueta \textless script\textgreater\space y crear el componente \textless a-scene\textgreater.
	
	\item Como vemos en la Figura~\ref{fig:aframe_code}, se utiliza un HTML sencillo de entender y reutilizable. Es accesible para todo tipo de público, desde desarrolladores a educadores, artistas, diseñadores y niños.
	
	\begin{figure}
		\centering
		\includegraphics[width=12cm, keepaspectratio]{img/aframe_code}
		\caption{Ejemplo código HTML de A-Frame}
		\label{fig:aframe_code}
	\end{figure}
	
	\item Utiliza una arquitectura basada en entidad-componente. Es decir nos provee de una interfaz para reutilizar, declarar y acceder a objetos diseñados y optimizados de Three.js. Además, nos permite el acceso a cualquier elemento del DOM e incluso al motor de bajo nivel WebGL.
	
	\item Es una librería VR diseñada para ser multidispositivo y multiplataforma. Como se ha mencionado anteriormente es compatible con Vive, Rift, Windows Mixed Reality, Daydream, GearVR y Cardboard con soporte para todos los controladores respectivos.
	
	\item El rendimiento es otro punto fuerte de esta librería. A-Frame está optimizada desde cero para WebVR. Los componentes no manipulan el motor de diseño 3D del navegador y las actualizaciones se realizan en memoria llegando a alcanzar los 90 {\textit{fps}} en escenas con infinidad de elementos.
	
	\item La librería de A-Frame nos proporciona un poderoso elemento diseñado para ayudar al desarrollo. Este componente es el inspector de elementos que vemos en la Figura~\ref{fig:aframe_inspector} . Este inspector recuerda a la manera de crear escenas en otros motores gráficos como el de Unity3D\footnote{\url{https://unity.com/es}}. Pero la principal característica es que, gracias a él, podemos realizar cambios en la escena en vivo. Pudiendo añadir y borrar elementos e incluso actualizar los atributos de cada componente.
	
	\begin{figure}
		\centering
		\includegraphics[width=12cm, keepaspectratio]{img/aframe_inspector}
		\caption{Ejemplo del inspector de A-Frame}
		\label{fig:aframe_inspector}
	\end{figure}
	
	\item Los componenetes principales que nos proporciona A-frame son geometrías, materiales, luces, animaciones, modelos, difusores de rayos, sombras, audio posicional, texto y soporte para la mayoría de auriculares. La comunidad además ha aportado otros como medio ambiente , el estado , los sistemas de partículas , la física , los océanos y la realidad aumentada.
	
	\item Es una librería de probada escalabilidad llegando a ser utilizada por grandes empresas como Google, Disney, Samsung, Toyota, Ford, Chevrolet, CERN, NPR. Compañías como Google, Microsoft, Oculus y Samsung han realizado contribuciones para mejorar A-Frame.
	
		
	\begin{figure}
		\centering
		\includegraphics[width=12cm, keepaspectratio]{img/aframe_example}
		\caption{Ejemplo escena de A-Frame}
		\label{fig:aframe_example}
	\end{figure}
	
\end{itemize}

En esta potente librería de VR se basa este proyecto fundamentalmente.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DISEÑO E IMPLEMENTACIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Diseño e implementación}

En este apartado se muestra el diseño e implementación de este proyecto. Se comienza describiendo la metodología utilizada y las distintas etapas por las que ha pasado el proyecto. Más adelante profundizaremos en cada una de dichas etapas, describiendo el desarrollo que se ha realizado de manera incremental para este trabajo.


\section{Metodología Scrum} 
\label{sec:scrum}

La metodología que se ha seguido en este proyecto es la denominada metodología Scrum~\cite{blokehead:scrum}. Este procedimiento se caracteriza principalmente por ser incremental y estar enfocado al desarrollo de software ágil. A diferencia de otros métodos donde se desarrolla de manera secuencial o en cascada (requisitos, diseño, implementación, verificación y mantenimiento), la metodología Scrum permite solapar estas fases e incluso realizarlas mediante incrementos más pequeños.

El objetivo de Scrum es aplicar de manera regular buenas prácticas para trabajar en equipo y obtener el mejor resultado y calidad posible para el proyecto. Para esto se definen un conjunto de prácticas y roles como el de Scrum  \textit{máster} encargado del proceso asegurando su correcto uso y guiado por las distintas etapas, el \textit{product owner} el cual es el responsable de mantener el producto y asegurar la continuidad por las líneas de trabajo establecidas. Por último tenemos al equipo de desarrollo que debe ser multidisciplinar y encargado de ir cumpliendo las distintas iteraciones y tareas para sacar adelante el proyecto.

A continuación se describe brevemente cada una de las etapas o \textit{sprints} por las que ha pasado este proyecto:

\begin{itemize}
	\item \textbf{Iteración 0:} Esta es la fase previa donde se realizará un estudio de los requisitos del proyecto y las tecnologías a utilizar. La idea principal es familiarizarse con la librería A-Frame utilizando la documentación oficial y practicar mediante ejemplos básicos.
	
	\item \textbf{Iteración 1:} En esta primera etapa se tiene como objetivo crear las primeras escenas con gráficos en 3D. Para ello crearemos un repositorio de código inicial donde se va a usar nodeJS como servidor y Webpack como empaquetador de nuestra librería. Como objetivo final, se procederá a crear un primer gráfico para nuestra librería con un \textit{dataset} de ejemplo incrustado en el propio código JavaScript.
	
	\item \textbf{Iteración 2:} El segundo paso será empleado para enriquecer nuestra librería para que soporte un mayor número de gráficas. Se empezará a proporcionar un API para el uso de la librería. Además se procederá a separar la capa de datos de la aplicación para una mejor generalización.
	
	\item \textbf{Iteración 3:} En la tercera iteración se procederá a una refactorización total del código. Se utilizarán los estándares de A-Frame y crearemos un nuevo proyecto en GitHub, publicaremos nuestra librería en el repositorio de código de NodeJs.
	
	\item \textbf{Iteración 4:} En este apartado se realizará un enriquecimiento de la parametrización de nuestros gráficos pudiendo ser explotadas gracias al API proporcionado. Además se añadirán nuevos gráficos como el de tarta solicitado por la comunidad cerrando así las primeras incidencias.
	
	\item \textbf{Iteración 5:} En esta quinta y última iteración se procede a solucionar los distintos errores de funcionamiento de la librería. Se proporciona la posibilidad de una representación dinámica de los datos. Y por último se facilita la integración mediante ejemplos para ser utilizada con dispositivos de realidad virtual.
	
\end{itemize}

\section{Iteración 0. Estudio previo.} 
\label{sec:iteracion_0}

En esta fase previa se comienza realizando un estudio previo de las tecnologías que vamos a utilizar en el proyecto. Debido a que se tiene un amplio conocimiento de JavaScript y HTML vamos a cumplir directamente nuestro objetivo específico de estudiar el \textit{framework} A-Frame. Para este menester, se comienza visitando la web oficial de A-Frame\footnote{\url{https://aframe.io/}} donde se puede encontrar toda la documentación\footnote{\url{https://aframe.io/docs/0.9.0/introduction/}} necesaria para comenzar a crear escenas en 3D en nuestro navegador con unos simples pasos.

Para ello se va a comenzar creando un primer proyecto HTML que llamaremos provisionalmente A-Charts. Utilizaremos el IDE WebStorm\footnote{\url{https://www.jetbrains.com/webstorm/}} de la compañía Jetbrains para comenzar con el desarrollo. Crearemos un proyecto HTML vacío que constará de los siguientes componentes: última versión de la librería de A-Frame\footnote{\url{https://aframe.io/releases/0.9.2/aframe.min.js}} mimificada, y el siguiente fichero HTML con el código que vemos a continuación.

\lstinputlisting[language=Html]{code/iteracion0-index.html} 


Como se puede ver en el código, A-Frame interpreta distintas etiquetas de marcado como:

\begin{itemize}
	\item[--] \textless a-scene\textgreater: La escena es el objeto raíz global, y todas las entidades están contenidas dentro de la escena.
	\item[--] \textless a-box\textgreater: Es una de las formas geométricas primitivas de la librería y crea formas como cajas, cubos o paredes.
	\item[--] \textless a-sphere\textgreater: Otra forma primitiva para crear una forma esférica o poliedro
	\item[--] \textless a-cylinder\textgreater: Esta etiqueta crea figuras geométricas en forma de tubo y superficies curvadas.
	\item[--] \textless a-plane\textgreater: Una primitiva más para crear superficies planas.
	\item[--] \textless a-sky\textgreater: El cielo agrega un color de fondo o una imagen de 360 ??° a una escena. Un cielo es una esfera grande con un color o textura mapeada hacia adentro.
	\item[--] \textless a-camera\textgreater: Componente que define desde qué perspectiva el usuario ve la escena
\end{itemize}


Estas etiquetas son las más basicas y el resultado podemos verlo en la siguiente Figura~\ref{fig:iteracion0}



\begin{figure}
	\centering
	\includegraphics[width=12cm, keepaspectratio]{img/iteracion0}
	\caption{Primera escena con A-Frame}
	\label{fig:iteracion0}
\end{figure}

\section{Iteración 1. Primer gráfico.} 
\label{sec:iteracion_1}

En esta primera iteración vamos a proceder a la creación de un repositorio de código en GitHub donde subiremos nuestros primeros desarrollos de la librería. se van a crear dos ramas de desarrollo, develop y master, en nuestro repositorio de git. De esta manera podremos ir desarrollando y probando distinta funcionalidad y solo subiremos a nuestra rama principal cuando tengamos el código probado y listo para producción.

Además, vamos a proceder a nuestra iniciación en el mundo con proyectos NodeJs y Webpack. Para todos estas tecnologías, el tutor de esta memoria ha proporcionado una web\footnote{\url{https://jgbarah.github.io/aframe-playground/}} con documentación y ejemplos que también han ayudado en el estudio previo a realizar.

Con esta información, se genera un nuevo proyecto llamado A-Charts con la arquitectura que vemos en la Figura~\ref{fig:arquitecturaAlpha} 

\begin{figure}
	\centering
	\includegraphics[width=8cm, keepaspectratio]{img/arquitecturaAlpha}
	\caption{Primera arquitectura del proyecto}
	\label{fig:arquitecturaAlpha}
\end{figure}

Primero se comienza aprendiendo que es Webpack y para qué se utiliza. Como se describe en el estado de arte, esta teconología es utilizada para empaquetar módulos estáticos. En la programación modular, los desarrolladores particionan su código en pequeños bloques que cumplen una funcionalidad concreta, y a estos se le llama módulos. 

Por tanto, para empezar a usar esta herramienta se crea el fichero de configuración llamado \textit{webpack.config.js}:

\lstinputlisting[language=JavaScript]{code/iteracion1-webpack.js}

En esta configuración se establece que nuestro código, estará en \textit{src/acharts.js} y su salida bundle.js en el directorio dist. Además se le especifican donde tendremos nuestros módulos JavaScript así como el transpilador a utilizar, en este caso babel y el módulo de HTML. Por otro lado se utilizará el plugin de HTML para webpack y definir nuestro template.

Por otro lado se comienza con la configuración del servidor web NodeJs. Para ello es necesario un fichero llamado package.json donde se especifican los metadatos del proyecto como nombre, descripción, versión, licencia, repositorio, etc.

A continuación se describen las líneas del fichero package.json que detallan las acciones para las etapas de desarrollo y despliegue.
\begin{lstlisting}[language=json,firstnumber=1]
{
	"scripts": {
		"dev": "webpack --mode development",
		"build": "webpack --mode production",
		"watch": "webpack --mode development --watch",
		"test": "echo \"Error: no test specified\" && exit 1",
		"start": "webpack-dev-server --mode development --content-base dist/",
		"clean": "rm -r dist/*",
		"cleanbuild": "rm -r dist/* && webpack --mode production"
	}	
}
\end{lstlisting} 

Y por último las dependecias del proyecto también incluidas en nuestro fichero package.json. Node automáticamente buscará estas dependencias en el repositorio de npm y las guardará en el directorio \textit{\texttt{node\_modules}} .

\begin{lstlisting}[language=json,firstnumber=1]
{
	"devDependencies": {
		"babel-core": "^6.26.0",
		"babel-loader": "^7.1.4",
		"babel-preset-env": "^1.6.1",
		"copy-webpack-plugin": "^4.5.1",
		"file-loader": "^1.1.11",
		"html-loader": "^0.5.5",
		"html-webpack-plugin": "^3.0.6",
		"webpack": "^4.1.1",
		"webpack-cli": "^2.0.11",
		"webpack-dev-server": "^3.1.1"
	},
	"dependencies": {
		"aframe": "^0.8.2"
	}	
}
\end{lstlisting} 

Una vez configurado el proyecto comenzaremos a escribir nuestro template HTML.

\lstinputlisting[language=Html, title= template.html]{code/iteracion1-template.html}

Como se ve en el código HTML del template, se definen varias etiquetas que el motor de A-Frame interpreta. En el apartado \textit{Iteración 0}, se explican varias de las etiquetas básicas utilizadas en el \textit{template.html} tales como \textless a-scene\textgreater, \textless a-sky\textgreater, \textless a-light\textgreater y \textless a-camera\textgreater. 

Además se añaden una entidad genéricas de A-Frame con la etiqueta \textless a-entity\textgreater. Estas entidades, son componentes genéricos listos para proporcionar una apariencia, comportamiento y funcionalidad determinada. Dichas cualidades se generan mediante código JavaScript completando estos componentes.
Por tanto se puede decir que el objetivo de esta librería sería,  mediante estas entidades genéricas, dotar de a nuestro HTML de los gráficos que se requieran.

Como se puede ver, la etiqueta \textless a-entity\textgreater tiene un identificador para generar un componente llamado \textit{axis}, el cual representará los ejes x,y,z en 3D. Esta definición, entre otras, quedará reflejada en el fichero \textit{src/acharts.js} visto en la Figura 4.2. detallado a continuación por partes.

Primero se comienza importando la librería de A-Frame.

\lstinputlisting[language=JavaScript, title= Importación librería A-Frame]{code/iteracion1-import.js}

Se definen los puntos que tendrá nuestro gráfico de barras en tres dimensiones x,y,z. Además se definen los atributos color y altura.
\lstinputlisting[language=json, title= JSON para representar el  gráfico]{code/iteracion1-points.json}

A continuación se define la función encargada de generar nuestro gráfico de barras una vez el DOM haya sido cargado. Lo primero de todo, almacenamos en la variable \textit{scene} la entidad a-scene de A-Frame. Recorremos todos los puntos previamente definidos en la variable \textit{barPlotItems} y por cada punto, creamos una nueva entidad con el atributo \textit{barplot}. Esto quiere decir que cada entidad tomará el comportamiento, funcionalidad y estilo que hayamos registrado en el componente de A-Frame \textit{barplot}. Además a cada nueva entidad se le pasan como argumento una lista de valores definidos en el esquema del componente que veremos a continuación. Por último, añadimos cada nueva entidad a la escena con la función \textit{appendChild}.
\clearpage

\lstinputlisting[language=JavaScript, title= Función ejecutada al cargarse el DOM]{code/iteracion1-loader.js}

En este siguiente paso vamos a registrar nuestro componente \textit{barplot} mediante la función \textit{registerComponent} de A-Frame. A esta función se le pasa como argumento el nombre, el cual será usado como atributo HTML en la representación del componente en el DOM. Luego se añade la definición del componente, que es un objeto JavaScript de métodos y propiedades. Estos métodos pueden definir el manejo del ciclo de vida del componente.

En este caso, la definición del componente constará de la posición, el color, la altura, el tamaño y el tipo. Este último nos servirá en un futuro para que nuestro componente no sólo sea un gráfico de barras sino que pueda implementar distintos tipos de gráficos en función del esquema que se le pase.

Después, se implementa la función \textit{update} proporcionada por el core de A-Frame. Esta función es ejecutada cuando se modifica alguna propiedad de dicho componente (para actualizar el gráfico dinámicamente sin necesidad de refrescar la página web) o en el inicio del ciclo de vida del componente (después de la función \textit{init}) como es el caso.

Como vemos en el código, se comprueba que el tipo de gráfico sea \textit{cylinder}, es decir una barra cilíndrica, y si se cumple dicha condición, se rellenan todos los parámetros del esquema gracias al método \textit{self.data} donde tenemos almacenados todos los datos introducidos anteriormente. 


\lstinputlisting[language=JavaScript, title= Definición del componente barplot]{code/iteracion1-barplot.js}

Por último, se registra el componente \textit{axis}. En este caso, se define en el esquema del componente únicamente el color. Además se implementa nuevamente la función \textit{update}.

Dentro de esta función se generan el elemento \textit{line} de A-Frame varias veces. Se crean, en concreto, tres líneas por cada eje de coordenadas (x,y,z) con una longitud de diez unidades. Luego, por cada eje de coordenadas y de una en una unidad, se generan los \textit{ticks} (más líneas de longitud 0.4 unidades) para ayudar en la interpretación de la posición del gráfico final.

El componente \textit{line} dibuja una línea dada una coordenada de inicio y otra final. Como se expone anteriormente en el punto 3. Estado del arte, este componente lo hereda A-Frame de la librería Three.js y por tanto se tiene a disposición para su uso en esta librería.

\lstinputlisting[language=JavaScript, title= Definición del componente barplot]{code/iteracion1-axis.js}


Cuando arrancamos el proyecto con el comando \textit{start} definido en el fichero \textit{package.json} se obtiene como resultado el primer gráfico que se puede ver en la Figura~\ref{fig:iteracion1-resultado} 


\begin{figure}
	\centering
	\includegraphics[width=8cm, keepaspectratio]{img/iteracion1-resultado}
	\caption{Iteración 1: Resultado}
	\label{fig:iteracion1-resultado}
\end{figure} 

\clearpage

\section{Iteración 2. Enriquecimiento de la librería y separación de la capa de datos.} 
\label{sec:iteracion_2}

En esta segunda iteración tenemos como objetivo añadir más tipos de gráficos a nuestra librería. Cada gráfico será un nuevo componente que registraremos en A-Frame como se ha mostrado en la primera iteración.

Por otro lado vamos a separar los datos, los cuales forman puntos en el espacio tridimiensional, del código donde se generan las representaciones en sí. Para ello se crea uno o varios ficheros JSON con los datos y se especificará en el componente la ruta del fichero donde obtener estos datos.

Respecto al template HTML mostrado a continuación y al visto en la primera iteración se aprecian varios cambios. Para empezar se ha eliminado la entidad \textit{axis} ya que, como veremos más adelante, cada gráfico llamará al componente \textit{axis}. Por tanto, solo es necesario declarar una entidad de A-Frame teniendo como atributo el nombre del componente. 
\lstinputlisting[language=Html, title= template.html]{code/iteracion2-template.html}
Como se ve en la imagen \textit{template.html}, dentro del atributo \textit{bubble\_chart} añadimos cuatro propiedades: \textit{datapoints}, \textit{size}, \textit{position} y \textit{color}. Estas propiedades estan descritas en el esquema del componente que veremos a continuación.


En esta versión de la librería registraremos tres tipos de componentes, uno por cada tipo de gráfico. Solo necesitaremos poner el nombre del componente como atributo para que la librería de A-Frame renderice nuestro gráfico tal y como hemos visto en el código HTML anterior.

Los tres componentes que se desarrollan son \textit{bubble\_chart} (gráfico de burbujas), \textit{bar\_chart}(gráfico de barras cilíndricas o cúbicas) y \textit{line\_chart}(Para el gráfico de líneas).
Todos ellos siguen la siguiente estructura de código:
\begin{itemize}
	\item Registro del componente y definición del esquema.
	
	\lstinputlisting[language=JavaScript, title= Registro del componente y esquema]{code/iteracion2-schema.js}
	En este esquema se puede ver la concordancia del HTML visto anteriormente y el componente. Vemos que se definen las propiedades y el tipo de dato. La propiedad más importante y novedosa en esta iteración es la de \textit{datapoints}, a la cual se le especifica que sea de tipo \textit{asset} (activo o recurso). Esto quiere decir que vamos a poder pasar al componente una ruta donde tengamos nuestro fichero JSON con los datos del gráfico.
	
	La única diferencia de esquema entre los tres componentes es el atributo \textit{type}. Este atributo se usa únicamente en el componente \textit{bar\_chart} para especificar si queremos un gráfico con barras cilíndricas o cúbicas. En posteriores iteraciones se usará este concepto para unificar los componentes en uno siguiendo los estándares de A-Frame.

	\item Definición de la función \textit{init} y \textit{update}.
	\lstinputlisting[language=JavaScript, title= Funciones init y update]{code/iteracion2-init-update.js}
	
	La función \textit{init} es llamada al inicio del ciclo de vida del componente. Sirve para inicializar ciertas variables del componentes o funciones \textit{listener}. En este caso, se inicializa la función \textit{FileLoader}
	que nos provee Threejs encargada de cargar en memoria cualquier tipo de fichero.
	
	Por otro lado, la función \textit{update} es llamada después de la función \textit{init} en el ciclo de vida del componente. Además tiene la peculiaridad de ser invocada cada vez que se cambie algún atributo, por ello realizamos ciertas comprobaciones en el código. La primera de ellas, es comparar si el fichero de datos que se ha modificado es igual que el que teníamos cargado con la función \textit{deepEqual} de A-Frame. Si son iguales se ignora el fichero y no se realiza ningún trabajo.
	En la segunda comprobación volvemos a comprobar que los datos en JSON son efectivamente distintos y si el fichero contiene datos válidos. Si es así, invocamos a la función \textit{onDataLoaded} que hemos definido en nuestro componente. Esta función no es nativa de A-Frame, si no que ha sido implementada en este proyecto y es donde se desarrolla toda la lógica de nuestro componente.
	
	\item Definición de la función \textit{onDataLoaded}
	\lstinputlisting[language=JavaScript, title= Función onDataLoaded]{code/iteracion2-ondataloaded.js}
	Finalmente, se define la función \textit{onDataLoaded} cuyo argumento \textit{file} es el fichero de datos.
	Primero se crea el componente genérico \textit{axis} que utilizan todos los gráficos pasándole como esquema el color y la posición de los ejes.
	Seguidamente parseamos el fichero con la función JavaScript JSON.parse. Gracias a ella podemos recorrer cada punto del gráfico en un bucle.
	Por cada elemento de los datos del JSON se crea una entidad de A-Frame, en este caso \textless a-sphere\textgreater. Los atributos vienen dados por el propio fichero de datos y el esquema del componente. Además se le añade una pequeña función para que cuando pasemos el ratón por encima de cada elemento, este se haga mayor.
	
\end{itemize}

Cabe destacar que el componente \textit{axis} ha sido refactorizado respecto a la primera iteración. En este caso se ha subdividido en dos componentes, uno de ellos genérico donde se recorren los ejes x, y, z y el otro donde se crean las líneas y ticks de los propios ejes quedando de la siguiente manera:

\lstinputlisting[language=JavaScript, title= Componente axis]{code/iteracion2-axis.js}

Por último, se ha añadido a modo de ejemplo para uso de esta librería un menú de opciones. Si se selecciona alguna de estas opciones se sustituye el gráfico anterior por el seleccionado.

Para esto se han seguido los siguientes pasos:

\begin{itemize}
	\item Se añade al fichero \textit{webpack.config.js} las siguiente configuración para empaquetar CSS y JSON.	
	\lstinputlisting[language=JavaScript, title= webpack.config.js CSS y JSON]{code/iteracion2-webpack.js}
	
	\item Añadimos la dependencia \textit{css-loader} al fichero  \textit{package.json}.	
	\lstinputlisting[language=Json, title= Dependencia para package.json]{code/iteracion2-package.json}
		
	\item Código HTML para el menú de opciones
	\lstinputlisting[language=html, title= HTML menú de opciones]{code/iteracion2-menu.html}
	
	\item El CSS para el menú de opciones simplemente hace que el elemento con la clase \textit{div-opt} se posicione arriba a la izquierda de la web.
	
	\item Código JavaScript para el menú de opciones
	\lstinputlisting[language=JavaScript, title= JS menú de opciones]{code/iteracion2-menu.js}
	
\end{itemize}

Cuando arrancamos el proyecto, nuevamente con el comando \textit{start} definido en el fichero \textit{package.json}, se obtiene como resultado las Figuras~\ref{fig:iteracion2-resultado} y~\ref{fig:iteracion2-resultadob}.
\begin{figure}
	\centering
	\includegraphics[width=8cm, keepaspectratio]{img/iteracion2-resultado}
	\caption{Iteración 2: Resultado Gráfico de Barras}
	\label{fig:iteracion2-resultado}
\end{figure}
\begin{figure}
	\centering
	\includegraphics[width=8cm, keepaspectratio]{img/iteracion2-resultadob}
	\caption{Iteración 2: Resultado Gráfico de burbujas}
	\label{fig:iteracion2-resultadob}
\end{figure}
\clearpage

\section{Iteración 3. Refactorización y estandarización de la librería.} 
\label{sec:iteracion_3}

En esta iteración, el objetivo es publicar nuestro componente en la comunidad de A-Frame. Para ello seguimos las instrucciones de A-Frame Registry\footnote{\url{https://github.com/aframevr/aframe-registry}} donde debemos seguir una serie de pasos para cumplir con las \textit{best practices}.

Gracias a estas medidas tendremos nuestro componente correctamente versionado, publicado en varios repositorios de código listo para ser utilizado por terceros e incluso permitiendo la contribución de otros desarrolladores. Se creará un proyecto de cero donde integraremos nuestro antiguo componente siguiendo los siguientes pasos:
\begin{itemize}
	\item[--] En primer lugar se utiliza la herramienta \textit{angle}\footnote{\url{https://github.com/ngokevin/angle}}, la cual permite crear un proyecto de cero por línea de comando (Figura~\ref{fig:iteracion3-angle}). Se genera un componente con una arquitectura genérica (Figura~\ref{fig:iteracion3-arquitectura}).	
	\begin{figure}[H]
		\centering
		\includegraphics[width=16cm, keepaspectratio]{img/angle}
		\caption{Iteración 3: Inicializar proyecto con Angle}
		\label{fig:iteracion3-angle}
	\end{figure}
	\begin{figure}[H]
		\centering
		\includegraphics[width=6cm, keepaspectratio]{img/iteracion3-arquitectura}
		\caption{Iteración 3: Nueva Arquitectura}
		\label{fig:iteracion3-arquitectura}
	\end{figure}		
	\item[--] Se publica el componente en npm, el repositorio de paquetes de nodeJs, mediante el comando \textit{npm publish}. Para ello es necesario tener instalado npm en nuestro sistema y crearse una cuenta gratuita en la web oficial \footnote{\url{https://www.npmjs.com/}}
	
	\item[--] Se publica el componente en GitHub, un repositorio online de código. Para ello es necesario tener instalado git en nuestro sistema y crearse una cuenta gratuita en la web oficial \footnote{\url{https://github.com/}}. Una vez creado el proyecto en la web, debemos ir mediante línea de comandos donde tenemos nuestro proyecto y ejecutar \textit{git init}, \textit{git commit} y \textit{git push}.	
	
	\item[--] Se añade documentación sobre las propiedades del componente y una página de ejemplo de uso de la librería. Todo ello se puede consultar en la sección de Resultados. 
	
	\item[--] Se debe publicar una página web con ejemplos. Se propone \textit{GitHub Pages} la cual utilizamos para ver nuestro resultado\footnote{\url{https://adrixp.github.io/aframe-charts-component/}}.
	
	\item[--] Se debe añadir un enlace desde dicha página web al repositorio de GitHub.
	
	\item[--] Debe tener sentido en el contexto de una aplicación WebVR.
	
	\item[--] Debe incluir una imagen de vista previa o GIF en el archivo README.
	
	\item[--] Deberá seguir semver\footnote{\url{https://semver.org/}} en su esquema de versión de componente, reflejando la última versión estable de A-Frame.
	
	\item[--] Se debe auto registrar el componente con la función \textit{AFRAME.registerComponent}. En este último punto aprovechamos para realizar una refactorización del código. Nuestro template HTML queda de la siguiente manera:
	
	\lstinputlisting[language=html, title= Iteración 3: Template HTML]{code/iteracion3-template.html}
	
	Como se puede ver únicamente se instancia una entidad de A-Frame con el atributo \textit{charts}. Además, se utilizan dos propiedades, una donde se le indica la ruta del fichero de datos y el tipo de gráfico a representar.
	
	En cuanto al código JavaScript, únicamente registramos un componente llamado \textit{charts}. 
	
	\lstinputlisting[language=JavaScript, title= Iteración 3: Componente Charts]{code/iteracion3-component.js}
	
	Como vemos en su esquema, únicamente tendremos por ahora dos propiedades. La propiedad \textit{type} nos indica el tipo de gráfico que se va a generar, y en base a dicho tipo se selecciona una función u otra como la que vemos a continuación:
	
	\lstinputlisting[language=JavaScript, title= Iteración 3: Función para generar Gráfico Burbujas]{code/iteracion3-chart-function.js}
	
	Finalmente, el eje del gráfico también a recibido una refactorización importante de código quedando de la siguiente manera:
	
	\lstinputlisting[language=JavaScript, title= Iteración 3: Función para generar ejes]{code/iteracion3-axis.js}

\end{itemize}

El resultado final es un único componente, cuyo código es mucho más limpio y nos vale para generar distintos tipos de gráficos. Además, cumple con todas las recomendaciones de A-Frame. Cabe destacar que se ha eliminado el gráfico de líneas debido a que visualmente no aporta información sino confusión.


\section{Iteración 4. Poblamiento de funcionalidad de la API. Resolución de incidencias de la comunidad.} 
\label{sec:iteracion_4}


- Se añaden parametrización en los ejes. separacion de los ticks, grosor, posicion de los ejes y los ticks.

- Ejes parametrizables si hay datos negativos

- Grid axis

-Texto y numeración de los ejes, color y tamaño del mismo

-Se añade gráficos de cilindros

-Se añaden los gráficos de tarta y donut Gracias al Change Resquest de la comunidad! cerrando el issue

- Json de Datos, Formato para tarta y donut.


\section{Iteración 5. Adaptación para dispositivos de VR y representación dinámica de datos.} 
\label{sec:iteracion_5}

-Añadimos pop up

- Añadimos leyenda

-Pruebas de rendimiento (Creación de programa para generar random json con los datos que necesitamos)

-Añadimos la funcionalidad del totem. Cambiar datos de manera dinámica.

-Adaptación para Oculus Rift

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% RESULTADOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Resultados}

\section{Arquitectura general} 
\label{sec:arquitectura}

Hablo de la arquitectura con nodejs.

package json, index.js node modules.

Ejes.js

Leyenda.js

Totem.js

JSON para datos

Foto general de la arquitectura

\section{Funcionamiento de la Librería} 
\label{sec:funcionamiento_libreria}

Manual de usuario con lo que hay en la web.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONCLUSIONES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Conclusiones}
\label{chap:conclusiones}


\section{Consecución de objetivos}
\label{sec:consecucion-objetivos}

Esta sección es la sección espejo de las dos primeras del capítulo de objetivos, donde se planteaba el objetivo general y se elaboraban los específicos.

Es aquí donde hay que debatir qué se ha conseguido y qué no. 
Cuando algo no se ha conseguido, se ha de justificar, en términos de qué problemas se han encontrado y qué medidas se han tomado para mitigar esos problemas.

Todos conseguidos of course.


\section{Aplicación de lo aprendido}
\label{sec:aplicacion}

Aquí viene lo que has aprendido durante el Grado/Máster y que has aplicado en el TFG/TFM. Una buena idea es poner las asignaturas más relacionadas y comentar en un párrafo los conocimientos y habilidades puestos en práctica.

La de Meteor, La de Barahona de Js etc, alguna con Node

\begin{enumerate}
  \item a
  \item b
\end{enumerate}


\section{Lecciones aprendidas}
\label{sec:lecciones_aprendidas}

Aquí viene lo que has aprendido en el Trabajo Fin de Grado/Máster.
webpack
y todo lo que tenga en objetivos
A frame, realidad virtual

\begin{enumerate}
  \item a
  \item b
\end{enumerate}


\section{Trabajos futuros}
\label{sec:trabajos_futuros}

Ningún software se termina, así que aquí vienen ideas y funcionalidades que estaría bien tener implementadas en el futuro.

Integracion con ElasticSearch (Que pueda ser Near Real Time)
Otras bases de datos relacionales
Mayor customización y mas tipos de gráficos
Animaciones
Permitir añadir plugins y addons a la libreria
Crear comunidad
Dashboards
Mas Realidad Virtual

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BIBLIOGRAFIA %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage

% Las siguientes dos instrucciones es todo lo que necesitas
% para incluir las citas en la memoria
\bibliographystyle{abbrv}
\bibliography{memoria}  % memoria.bib es el nombre del fichero que contiene
% las referencias bibliográficas. Abre ese fichero y mira el formato que tiene,
% que se conoce como BibTeX. Hay muchos sitios que exportan referencias en
% formato BibTeX. Prueba a buscar en http://scholar.google.com por referencias
% y verás que lo puedes hacer de manera sencilla.
% Más información: 
% http://texblog.org/2014/04/22/using-google-scholar-to-download-bibtex-citations/

\end{document}
