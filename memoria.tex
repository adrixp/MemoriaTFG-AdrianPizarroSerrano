%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Plantilla de memoria en LaTeX para la ETSIT - Universidad Rey Juan Carlos
%%
%% Por Gregorio Robles <grex arroba gsyc.urjc.es>
%%     Grupo de Sistemas y Comunicaciones
%%     Escuela Técnica Superior de Ingenieros de Telecomunicación
%%     Universidad Rey Juan Carlos
%% (muchas ideas tomadas de Internet, colegas del GSyC, antiguos alumnos...
%%  etc. Muchas gracias a todos)
%%
%% La última versión de esta plantilla está siempre disponible en:
%%     https://github.com/gregoriorobles/plantilla-memoria
%%
%% Para obtener PDF, ejecuta en la shell:
%%   make
%% (las imágenes deben ir en PNG o JPG)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper, 12pt]{book}
%\usepackage[T1]{fontenc}

\usepackage[a4paper, left=2.5cm, right=2.5cm, top=3cm, bottom=3cm]{geometry}
\usepackage{times}
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel} % Comenta esta línea si tu memoria es en inglés
\usepackage{url}
%\usepackage[dvipdfm]{graphicx}
\usepackage{graphicx}
\usepackage{float}  %% H para posicionar figuras
\usepackage[nottoc, notlot, notlof, notindex]{tocbibind} %% Opciones de índice
\usepackage{latexsym}  %% Logo LaTeX
\usepackage[hidelinks]{hyperref}
\usepackage{listings}
\usepackage[table,xcdraw]{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}


\lstdefinelanguage{JavaScript}{
	keywords={break, case, catch, continue, debugger, default, delete, do, else, false, finally, for, function, if, in, instanceof, new, null, return, switch, this, throw, true, try, typeof, var, void, while, with, let, const, exports},
	morecomment=[l]{//},
	morecomment=[s]{/*}{*/},
	morestring=[b]',
	morestring=[b]",
	ndkeywords={class, export, boolean, throw, implements, import, this},
	keywordstyle=\color{blue}\bfseries,
	ndkeywordstyle=\color{darkgray}\bfseries,
	identifierstyle=\color{black},
	commentstyle=\color{purple}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	sensitive=true
}

\lstdefinelanguage{json}{
	basicstyle=\normalfont\ttfamily,
	numbers=left,
	numberstyle=\scriptsize,
	stepnumber=1,
	numbersep=8pt,
	showstringspaces=false,
	breaklines=true,
	frame=lines,
	backgroundcolor=\color{background},
	literate=
	*{0}{{{\color{numb}0}}}{1}
	{1}{{{\color{numb}1}}}{1}
	{2}{{{\color{numb}2}}}{1}
	{3}{{{\color{numb}3}}}{1}
	{4}{{{\color{numb}4}}}{1}
	{5}{{{\color{numb}5}}}{1}
	{6}{{{\color{numb}6}}}{1}
	{7}{{{\color{numb}7}}}{1}
	{8}{{{\color{numb}8}}}{1}
	{9}{{{\color{numb}9}}}{1}
	{:}{{{\color{punct}{:}}}}{1}
	{,}{{{\color{punct}{,}}}}{1}
	{\{}{{{\color{delim}{\{}}}}{1}
	{\}}{{{\color{delim}{\}}}}}{1}
	{[}{{{\color{delim}{[}}}}{1}
	{]}{{{\color{delim}{]}}}}{1},
}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}

\lstset{style=mystyle}

\title{Memoria del Proyecto}
\author{Nombre del autor}

\renewcommand{\baselinestretch}{1.5}  %% Interlineado

\begin{document}

\renewcommand{\refname}{Bibliografía}  %% Renombrando
\renewcommand{\appendixname}{Apéndice}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PORTADA

\begin{titlepage}
\begin{center}
\begin{tabular}[c]{c c}
%\includegraphics[bb=0 0 194 352, scale=0.25]{logo} &
\includegraphics[scale=0.25]{img/logo_vect.png} &
\begin{tabular}[b]{l}
\Huge
\textsf{Universidad} \\
\Huge
\textsf{Rey Juan Carlos} \\
\end{tabular}
\\
\end{tabular}

\vspace{3cm}

\Large
ESCUELA TÉCNICA SUPERIOR DE INGENIERÍA DE TELECOMUNICACIÓN

\vspace{0.6cm}

\Large
GRADO EN INGENIERÍA EN TECNOLOGÍAS DE LA TELECOMUNICACIÓN

\vspace{0.8cm}

\textbf{Trabajo Fin de Grado}

\vspace{2.5cm}

\LARGE
VISUALIZACIÓN DE DATOS EN REALIDAD VIRTUAL

\vspace{2cm}

\large
Autor : Adrián Pizarro Serrano \\
Tutor : Dr. Jesús M. González Barahona \\
Curso Académico 2019/2020
\end{center}
\end{titlepage}

\newpage
\mbox{}
\thispagestyle{empty} % para que no se numere esta pagina


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Para firmar
\clearpage
\pagenumbering{gobble}
\chapter*{}

\vspace{-4cm}
\begin{center}
\LARGE
\textbf{Trabajo Fin de Grado}

\vspace{1cm}
\large
Visualización de Datos en Realidad Virtual

\vspace{1cm}
\large
\textbf{Autor :} Adrián Pizarro Serrano \\
\textbf{Tutor :} Dr. Jesús M. González Barahona

\end{center}

\vspace{1cm}
La defensa del presente Proyecto Fin de Carrera se realizó el día \qquad$\;\,$ de \qquad\qquad\qquad\qquad \newline de 2020, siendo calificada por el siguiente tribunal:


\vspace{0.5cm}
\textbf{Presidente:}

\vspace{1.2cm}
\textbf{Secretario:}

\vspace{1.2cm}
\textbf{Vocal:}


\vspace{1.2cm}
y habiendo obtenido la siguiente calificación:

\vspace{1cm}
\textbf{Calificación:}


\vspace{1cm}
\begin{flushright}
Fuenlabrada, a \qquad$\;\,$ de \qquad\qquad\qquad\qquad de 2020
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Dedicatoria

\chapter*{}
\pagenumbering{Roman} % para comenzar la numeracion de paginas en numeros romanos
\begin{flushright}
\textit{Dedicado a \\
mi familia}
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Agradecimientos

\chapter*{Agradecimientos}
%\addcontentsline{toc}{chapter}{Agradecimientos} % si queremos que aparezca en el índice
\markboth{AGRADECIMIENTOS}{AGRADECIMIENTOS} % encabezado 

Quisiera dar las gracias, en primer lugar, a mi familia tanto a mis padres como mi hermano. Sin su apoyo diario, su constante dedicación y esfuerzo puesto en mi educación y bienestar nunca habría llegado donde estoy. Para mí son una parte fundamental de mi vida y gran parte de lo que soy. Estoy convencido de que sin su paciencia e insistencia nunca habría terminado el proyecto ni la carrera. Gracias por todo.

Otra gran protagonista y responsable de haber terminado este proyecto, es gracias a ti, Elena. Sin tu apoyo y sacrificio no habría podido terminar esta labor. Como bien sabes eres otra gran parte de mi vida y de lo que soy y seré en un futuro.

A mis amigos de toda la vida y a mis compañeros de carrera. Gracias por todas las buenas experiencias y recuerdos que siempre me llevaré y que seguiremos compartiendo. Por supuesto, sin vuestro apoyo y compañerismo hubiera sido un camino totalmente distinto y mucho  más difícil de recorrer.

Gracias a mi tutor Jesús M. González Barahona al cual llegué después de renunciar a otro proyecto y me acogió con los brazos abiertos. Siempre teniendo disponibilidad y prestándome ayuda cuando lo necesitaba.

Por último quisiera hacer una mención especial a la comunidad de desarrollo tan amplia que existe y gracias a la cual se comparte conocimiento diariamente y se consiguen avances increíbles.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen

\chapter*{Resumen}
%\addcontentsline{toc}{chapter}{Resumen} % si queremos que aparezca en el índice
\markboth{RESUMEN}{RESUMEN} % encabezado

Este proyecto consiste en el desarrollo de un módulo capaz de visualizar datos en tres dimensiones mediante realidad virtual. Este sistema puede ser utilizado en cualquier navegador y plataforma, así como visualizado con distintos dispositivos de realidad virtual.

Se utilizan distintas tecnologías en el \textit{frontend} que permiten visualizaciones clásicas así como otras no tan clásicas en tres dimensiones. Debido a la creciente necesidad de analizar grandes cantidades de información sumado a la inexistencia de un módulo para representar datos en 3D, hacen de este trabajo un proyecto apasionante.

Este módulo es completamente configurable para una mejor experiencia de usuario. Se provee de un API para modificar las distintas visualizaciones e incluir distintos complementos para una mejor representación y comprensión de los datos.

Se ha utilizado el \textit{framework} de A-Frame, el cual, permite construir experiencias de realidad virtual. Gracias al extenso API, entidades y componenetes que provee, se ha podido desarrollar con éxito este módulo. Como se explica en esta memoria, dicho \textit{framework} se apoya fundamentalmente en la librería ThreeJS cuyo motor gráfico es WebGL. Por tanto, básicamente se utiliza HTML5 y JavaScript para generar todas las visualizaciones necesarias.

El resultado final ha consistido en publicar este módulo en la comunidad, y que así, el resto de desarrolladores pueda utilizarlo y contribuir a su mejora continua. De hecho, se han atendido varias peticiones de distintos usuarios que ya utilizan este módulo en sus distintos proyectos.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen en inglés

\chapter*{Summary}
%\addcontentsline{toc}{chapter}{Summary} % si queremos que aparezca en el índice
\markboth{SUMMARY}{SUMMARY} % encabezado

This project consists in the development of a library able of visualizing data in three dimensions through virtual reality. This system can be used in any browser and platform, as well as visualized with different virtual reality devices.

Different technologies are used in the frontend that allow classic visualizations as well as others not so classic in three dimensions. Due to the growing need to analyze large amounts of information added to the absence of a module to represent 3D data, they make this work an exciting project.

This module is fully configurable for a better user experience. An API is provided in order to modify the different visualizations and include complements for a better representation and understanding of the data.

The A-Frame framework has been used, which allows to build virtual reality experiences. Thanks to the extensive API, entities and components it provides, this module has been successfully developed. As explained in this report, this framework relies primarily on the ThreeJS library whose graphic engine is WebGL. Therefore, HTML5 and JavaScript are basically used to generate all the necessary visualizations.

The final result has been to publish this module in the community, and so, the rest of developers can use it and contribute to its continuous improvement. In fact, several requests from different users that already use this module in their different projects have been committed.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen en inglés

\chapter*{Acrónimos}
%\addcontentsline{toc}{chapter}{Acrónimos} % si queremos que aparezca en el índice
\markboth{Acrónimos}{Acrónimos} % encabezado

\textbf{API:} Application Programming Interface

\textbf{HTML:} HyperText Markup Language

\textbf{HTTP:} HyperText Transfer Protocol

\textbf{JSON:} JavaScript Object Notation

\textbf{XML:} eXtensible Markup Language

\textbf{JS:} JavaScript

\textbf{3D:} Tres Dimensiones

\textbf{VR:} Virtual Reality

\textbf{DOM:} Document Object Model

\textbf{AJAX:} Asynchronous JavaScript And XML

\textbf{ES6:} ECMAScript 6

\textbf{IDE:} Integrated Development Environment

\textbf{SVN:} Subversion

\textbf{RAM:} Random Access Memory

\textbf{GPU:} Graphics Processing Unit

\textbf{FPS:} Frame Per Second


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ÍNDICES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Las buenas noticias es que los índices se generan automáticamente.
% Lo único que tienes que hacer es elegir cuáles quieren que se generen,
% y comentar/descomentar esa instrucción de LaTeX.

%%%% Índice de contenidos
\tableofcontents 
%%%% Índice de figuras
\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de figuras} % para que aparezca en el indice de contenidos
\listoffigures % indice de figuras
%%%% Índice de tablas
%\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de tablas} % para que aparezca en el indice de contenidos
%\listoftables % indice de tablas


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INTRODUCCIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Introducción}
\label{sec:intro} % etiqueta para poder referenciar luego en el texto con ~\ref{sec:intro}
\pagenumbering{arabic} % para empezar la numeración de página con números

Este proyecto trata sobre la visualización de datos mediante realidad virtual en cualquier navegador web y dispositivo VR. Se utiliza como base el {\textit{framework}} A-Frame\footnote{\url{https://aframe.io/}}. Esta biblioteca nace a su vez a partir de la librería Three.js\footnote{\url{https://threejs.org/}} utilizada para mostrar gráficos animados en 3D.

El objetivo principal es crear un módulo capaz de visualizar datos con distintos tipos de gráficos, fácilmente escalable, mantenible y sencilla de utilizar. Además, como objetivos más específicos, podrá ser usada en cualquier navegador y dispositivo de realidad virtual.

El hecho de que apenas existan librerías para representación de datos con realidad virtual hacen de este proyecto un trabajo estimulante y motivador.

A continuación se describe el contexto, motivación, los objetivos, la estructura de esta memoria y la disponibilidad del software.

\section{Contexto}
\label{sec:contexto}

Hoy en día, prácticamente todo negocio se lleva a cabo o se promociona a través de Internet. La comunicación y la rentabilidad empresarial han mejorado enormemente gracias a la llegada de este fenómeno y de su mano surge el desarrollo web, el cual es uno de los mayores creadores de nuevos puestos de trabajo. 

Para todo este paradigma surgen, casi a diario, nuevos {\textit{frameworks}} para conseguir una mayor eficiencia y estandarización a la hora de crear páginas webs.

Cabe destacar que, a nivel empresarial, es necesario un estudio exhaustivo así como una mejor visualización, tratamiento y explotación de los datos. Para ello han surgido infinidad de librerías a nuestra disposición tales como D3.js\footnote{\url{https://d3js.org/}}, amcharts\footnote{\url{https://www.amcharts.com/}}, highcharts\footnote{\url{https://www.highcharts.com/}}, etc. 

Por otro lado, con el nacimiento de Canvas 3D en 2006 y su posterior evolución en WebGL se abre la puerta a la implementación de visualizaciones 3D en páginas webs. Como veremos más adelante, WebGL nos proporciona un API en javascript para renderizar visualizaciones 2D y 3D sobre HTML.

Paralelamente, nace el motor gráfico Unity el cual también ha ayudado a impulsar la fama y utilización de componentes 3D en múltiples plataformas. Ha sentado varias bases y conceptos reutilizados en muchas otras plataformas tales como el concepto de escena, cámaras, materiales, luces, sombras, formas geométricas y parámetros para cada componente.

Más tarde, y concerniente a este proyecto, nace Three.js como librería javascript basada en WebGL para crear y mostrar visualizaciones 3D. Esta librería ya nos proporciona todas las especificaciones necesarias para trabajar con escenas, efectos, animaciones, cámaras, etc. Para un uso más sencillo y estándar de esta librería y para su adaptación a la realidad Virtual nace A-Frame en 2015. Gracias a esta última librería podemos utilizar todos nuestras escenas 3D y representarlas en lo que conocemos como WebVR, la cual es una interfaz que nos provee del soporte necesario para visualizar todo este contenido HTML 3D en un aparato de realidad virtual (Oculus Rift, HTC Vive y Google Cardboard) o un navegador.

Finalmente me gustaría hacer una mención especial a toda la comunidad que hay detrás de todas estas plataformas. Sin su aportación diaria, intercambio de conocimiento y ayuda nada de esto sería posible.

La unión de estos dos mundos, representación de datos y la llegada de visualizaciones 3D en navegadores web, nos lleva a nuestro siguiente apartado la motivación.

\section{Motivación}
\label{sec:motivacion}

Muchas veces se escucha la frase atribuida al filósofo inglés Francis Bacon ``La información es poder'', la cual es cierta, pero sin una correcta interpretación de la misma podemos caer en el caso de la desinformación. Como se menciona en el apartado anterior la visualización y explotación de datos es un campo en auge del cual se requiere mucha ingeniería para poder sacarle partido. Es un campo apasionante, lleno de retos, con muchas salidas laborales y en constante evolución.

Hasta ahora, tenemos infinidad de librerías para representar datos en 2D pero ¿Qué ocurre con la llegada del 3D a nuestros navegadores? ¿Existen librerías para visualizar datos utilizando realidad virtual o realidad aumentada? Lo cierto es que estas preguntas nos llevan a una de las motivaciones principales de este proyecto. Este mundo es relativamente nuevo y hasta ahora se ha apostado más por realizar visualizaciones complejas en 3D o videojuegos. Por lo que la representación de datos en 3D es un nicho aun por explotar.

Este último punto ha sido muy motivador para realizar una de las primeras librerías capaz de visualizar datos en 3D tanto en un navegador como en dispositivos de realidad virtual. Además, la intención de este proyecto es que sea escalable, mantenible y el resto de la comunidad pueda contribuir a su uso y desarrollo.

Respecto a la motivación personal podemos decir que siempre he querido publicar un módulo en el que la comunidad pueda participar y contribuir. Ha sido muy gratificante ver como distintos usuarios han incluido esta biblioteca en sus proyectos así como realizado peticiones de mejora e inclusión de nuevos gráficos. Por otra parte, las tecnologías que se han utilizado en este proyecto son pioneras en el \textit{frontend} sumado al uso de la realidad virtual como medio para reproducir distintas escenas hacen de este proyecto un trabajo apasionante.

Es así como gracias a todos estos factores se ha podido finalizar este proyecto y escritura de esta memoria.

\section{Objetivo general} % título de sección (se muestra)
\label{sec:objetivo-general} % identificador de sección (no se muestra, es para poder referenciarla)

Este proyecto consiste en crear un sistema para la visualización de datos en 3D compatible con cualquier navegador. La cual además pueda ser usada en dispositivos de realidad virtual.

\section{Objetivos específicos}
\label{sec:objetivos-especificos}

En este apartado se realiza una breve descripción de los objetivos específicos.

\begin{enumerate}
	
	\item Este módulo se debe poder utilizar en cualquier navegador sin necesidad de instalar ningún plugin. Además, se podrá visualizar en distintos dispositivos de realidad virtual.
	
	\item Debe proporcionar varios tipos de visualizaciones tales como gráfico de burbujas, de tarta, de barras, de cilindros o tarta en forma de rosquilla.
	
	\item Se podrá colocar una o varias visualizaciones en cualquier parte del espacio tridimensional.
	
	\item Las visualizaciones podrán ser configurables por el usuario. Por ejemplo, se podrá modificar la posición, color, longitud y separación entre las marcas de medición de los ejes. Permitir que los ejes puedan ser negativos o estén en forma de rejilla para dos o más dimensiones. Poder configurar tamaño y color de la leyenda.	
	
	\item El sistema debe ser capaz de añadir una leyenda a un gráfico y/o un pop-up para una mejor interpretación de los datos. Con ello se persigue obtener más información y facilitar la lectura de datos.
	
	\item La biblioteca debe proporcionar una herramienta para filtrar o seleccionar distintas fuentes de datos. Además las visualizaciones se podrán refrescar dinámicamente.
	
	\item Debe ser capaz de interpretar ficheros o datos con formato JSON (JavaScript Object Notation) y lanzar una excepción si no fuera capaz de leer el archivo correctamente.
	
	\item El rendimiento es un factor clave que se desea cuidar en este proyecto. Por ello, esta librería debe mostrar un buen comportamiento cargando grandes volúmenes de datos. Se debe comprobar que es capaz de mostrar visualizaciones con una gran cantidad de datos.
	
	\item La librería se debe distribuir y poner al servicio de la comunidad. Se debe dar fácil acceso y ser subida a un repositorio de código donde se puedan recibir sugerencias para implementar y resolver posibles incidencias.
	
	\item Debe ser fácilmente escalable, es decir, deberá estar desarrollada de tal manera que sea sencillo implementar nuevos desarrollos o modificaciones en el código.
	
	\item Un objetivo importante es que el código deberá ser mantenible tanto por su autor como por la comunidad. Se debe publicar dicho software en una plataforma donde, como se menciona anteriormente, se pueda contribuir a resolver incidencias y mantener actualizado de manera sencilla las versiones de los framework y librerías que utilizará el proyecto.
	
	\item Aprender el framework de A-Frame, el cual viene dado desde el principio como recomendación del tutor. Se debe estudiar en profundidad su documentación y estándares para un uso óptimo de la misma. Esta librería de realidad virtual está basada en Three.js por lo que también se deberá realizar un estudio de la misma.
	
	\item Aprender Webpack para empaquetar y distribuir nuestra librería.	
	
	\item Crear el proyecto con Angle. Una herramienta hecha por los creadores de A-Frame para comenzar nuestro componente con un arquetipo que sigue los estándares de A-Frame.
	
	\item Crear una web con ejemplos de uso de la librería.
	
	\item Una vez creado el proyecto siguiendo los estándares y después de realizar los primeros avances se deberá publicar nuestro proyecto en el registry de A-Frame donde aparecen todos los componentes de la comunidad de A-Frame. Esto proporcionará visibilidad al proyecto pudiendo salir en el blog oficial llamado Week of A-Frame 
	
	\item Se deberá cuidar y refactorizar el código para una lectura sencilla del mismo siguiendo distintas directrices que podemos encontrar en el libro Clean Code~\cite{martin:_cleancode}.
	
\end{enumerate}

\section{Estructura de la memoria}
\label{sec:estructura}

En esta sección se describe la estructura de la memoria para una mejor compresión de la misma:

\begin{itemize}
  \item En el primer capítulo se hace una breve introducción al proyecto. Describiremos el marco y contexto del trabajo para un mejor aterrizaje del lector. Acto seguido, se habla de la motivación del proyecto tanto a nivel personal como profesional. Después se describe el objetivo principal que perseguimos con este trabajo para continuar con los específicos, donde se profundizará y ampliarán los conceptos tratados en el principal. Por último se describe brevemente la estructura de la memoria.
  
  \item A continuación se presenta el estado del arte. Aquí haremos un repaso así como una breve descripción de todas las tecnologías que se han utilizado.
  
  \item En el cuarto capítulo se desarrolla el diseño e implementación. Se entrará al detalle de como está construida la aplicación, su arquitectura y sus distintos componentes.
  
  \item En este quinto capítulo, Resultados, se realiza un análisis del funcionamiento y rendimiento de esta aplicación. Además se podrá ver un amplio abanico de casos de uso donde se verán los resultados y capacidades del proyecto.
   
  \item Por último, tendremos las conclusiones. Aquí se presentará un resumen de los distintos conceptos aprendidos y aplicados. Podremos ver si se han alcanzado los objetivos propuestos. Además se expondrán líneas futuras de investigación y mejora de esta aplicación.
\end{itemize}

\section{Disponibilidad del Software}
\label{sec:disponibilidad-software}

Para poder consultar y mantener el proyecto se ha creado un repositorio de software en el portal de GitHub. Este proyecto de software libre cuenta con una licencia de Apache 2.0. Todos los aportes a lo largo del tiempo así como las incidencias se pueden consultar en:
\vspace{5mm}

\url{https://github.com/adrixp/aframe-charts-component}

\vspace{5mm}
Además esta librería cuenta con una página web donde podemos ver las \textit{demos} y casos de uso. También se tiene un enlace directo al API para ver todos los parámetros disponibles, y por cada visualización el código utilizado. Se puede acceder a través del siguiente enlace:

\vspace{5mm}

\url{https://adrixp.github.io/aframe-charts-component/}

\vspace{5mm}

Por último, se ha publicado la librería en el sistema de gestión de paquetes (npm). Para facilitar su distribución y poder ser importado por un servidor nodejs en cualquier momento:

\vspace{5mm}

\url{https://www.npmjs.com/package/aframe-charts-component/}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ESTADO DEL ARTE %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Estado del arte}

En este capítulo se describirán las tecnologías que se utilizan en este trabajo. Se hará un repaso tanto de los lenguajes básicos de programación web utilizados, el servidor web y las herramientas para la paquetización y distribución de la librería.

También se mencionarán las librerías de realidad virtual y los motores en los que estas se apoyan, los cuales facilitan enormemente el trabajo de desarrollo.

\section{HTML5} 
\label{sec:htmlseccion}
\begin{center}
\includegraphics[scale=0.30]{img/html.png}
\end{center}

En 1993 se lanza el lenguaje de marcado HTML como herramienta principal para construir páginas web. Define una estructura básica a partir de etiquetas que son interpretadas por los navegadores. El encargado de su mantenimiento y estandarización es el Consorcio de la {\textit{World Wide Web}} (W3C).

Mas adelante, en 2014, se lanza la quinta versión de HTML comúnmente conocida como HTML5~\cite{pilgrim:_htmluprun}. En esta nueva versión se incluyen nuevos elementos como la cabecera \textless header\textgreater, el pie \textless footer\textgreater\space y la sección \textless section\textgreater\space entre otros. Además se añaden elementos gráficos como Canvas, una superficie bidimensional para dibujar mediante Javascript, y svg para gráficos vectoriales.

Por otro lado también se incluyen nuevos atributos y etiquetas para elementos multimedia como audio y video. Además, cabe destacar que el nuevo API nos provee de herramientas para la geolocalización, \textit{drag and drop}, almacenamiento local, caché, etc.

Finalmente subrayar que se proporciona una mayor optimización en el uso del \textit{hardware} así como la inclusión del estándar CSS3 el cual ofrece una nueva gran variedad de opciones para hacer diseños más sofisticados.


\section{JavaScript} 
\label{sec:jsseccion}
\begin{center}
\includegraphics[scale=0.30]{img/js.png}
\end{center}

Para dotar de funcionalidad y dinamismo a las páginas web, que como mencionamos anteriormente utilizan el lenguaje de marcado HTML, tenemos JavaScript~\cite{flanagan:_jsguide}. En 1995 nace este lenguaje orientado a objetos, el cual tiene tipado dinámico y utiliza prototipos en vez de clases para el uso de herencia.

El estándar que sigue este lenguaje actualmente es ECMAScript Todos los navegadores incluyen una implementación de dicho estándar. En este proyecto utilizamos la última versión publicada en 2015 ECMAScript 6 (ES6).

Este lenguaje puede ser utilizado tanto en el lado del cliente como en el lado del servidor como se puede ver más adelante. En el lado del cliente se nos ofrece infinidad de posibilidades para manipular el DOM.

Por último cabe destacar la infinidad de {\textit{frameworks}} que surgen día a día en la actualidad. Un {\textit{framework}} define el diseño completo de una aplicación web y nos facilita el uso de patrones de diseño~\cite{gamma:_designpatterns} como, por ejemplo, el Modelo Vista Controlador (MVC). Hoy en día tenemos a Angular.js\footnote{\url{https://angularjs.org/}}, React\footnote{\url{https://reactjs.org/}} y Vue.js\footnote{\url{https://vuejs.org/}} como los {\textit{frameworks}} más populares

\section{JSON} 
\label{sec:jsonseccion}

Como alternativa a XML nace JSON. Es un formato de texto para la distribución de datos o puede ser usado como un objeto Javascript que tiene distinta información, como vemos en la Figura~\ref{fig:json},  debido a su gran versatilidad. Es un formato muy sencillo de leer y de {\textit{parsear}}, es decir, de obtener su información.

\begin{figure}[H]
	\centering
	\includegraphics[width=9cm, keepaspectratio]{img/json}
	\caption{Ejemplo JSON básico}
	\label{fig:json}
\end{figure}

Los tipos de datos que soporta JSON son: números, texto, {\textit{booleanos}}, {\textit{arrays}} y objetos Javascript formados por tuplas clave-valor. Y en comparación con XML tiene un mayor soporte y herramientas para su uso.
En este proyecto se va a utilizar JSON como formato de entrada de datos. Además, se puede ver en los siguientes puntos que para resolver las dependencias de nuestro proyecto y dar una descripción general del mismo se utiliza un fichero de datos llamado {\textit{package.json}}.

\section{NodeJS} 
\label{sec:nodeseccion}
\begin{center}
\includegraphics[scale=0.30]{img/node.png}
\end{center}

NodeJs~\cite{pasquali:_nodejs} es un servidor web desarrollado en C++ en el año 2009. Esta plataforma nos permite desarrollar en el lado del servidor con el lenguaje Javascript y el estándar ES6.

Es un servidor cuyas características principales son que es {\textit{monohilo}} y asíncrono. Como vemos en la Figura~\ref{fig:nodeserver}, tenemos un único hilo donde por cada petición se delega el trabajo y se da respuesta de  manera asíncrona, es decir, no es bloqueante y se ejecutará de manera concurrente recibiendo dichas respuestas mediante funciones {\textit{callback}}.

\begin{figure}[H]
	\centering
	\includegraphics[width=12cm, keepaspectratio]{img/nodeServer}
	\caption{Arquitectura NodeJs}
	\label{fig:nodeserver}
\end{figure}

Como se menciona anteriormente, el archivo package.json es el corazón del sistema Node.js. Es el archivo de manifiesto de cualquier proyecto con Node.js y contiene los metadatos del proyecto. Además, en la siguiente sección, se podrá ver como el gestor de paquetes de node (NPM) utiliza este fichero para obtener información y descargar las dependencias.

Cabe destacar que NodeJs se utiliza como servidor web en infinidad de compañías y tiene una fuerte comunidad detrás apoyando su desarrollo.

\section{npm} 
\label{sec:npmseccion}
\begin{center}
	\includegraphics[scale=0.30]{img/npm.png}
\end{center}
Como gestor de paquetes, módulos y dependencias de NodeJs nace npm en 2014. Es instalado automáticamente con cualquier versión de NodeJs a partir de la 0.6.3. Las instrucciones se ejecutan por línea de comandos y cualquier usuario puede consumir los paquetes subidos a esta plataforma de manera versionada.

Para este proyecto se ha creado un repositorio de npm para poder distribuir nuestra propia librería como dependencia y poder ser usada de manera ágil\footnote{\url{https://www.npmjs.com/package/aframe-charts-component}}. Es necesario registrarse en la plataforma para poder publicar.

Gracias a esta herramienta se facilita el poder crear, compartir, reutilizar y contribuir a los distintos módulos desarrollados por la comunidad.

\section{Budo} 
\label{sec:budoseccion}

Budo es una herramienta que nos permite desarrollar en el servidor con integración {\textit{LiveReload}}. Esto nos permite que cualquier cambio que realicemos en el servidor se vea reflejado instantáneamente sin necesidad de recargar toda la instancia. Para ello, Budo utiliza otro paquete npm llamado {\textit{broserfy}} que nos permite exportar módulos y dependencias en el cliente.

En este proyecto ha sido muy útil esta herramienta ya que ha facilitado y agilizado el desarrollo. Este paquete está disponible en el repositorio de npm

\section{HighlightJs} 
\label{sec:highlightseccion}

Esta librería es utilizada para representar código de manera legible en una página web. Nos permite mostrar cualquier lenguaje de programación resaltando las palabras clave como si estuviéramos utilizando un IDE (Entorno de desarrollo) o un editor de texto que tuviera esta funcionalidad.

Como parámetros de entrada, esta librería, acepta nombre del lenguaje de programación, un alias o directamente código. Además cuenta con la posibilidad de resaltar texto a pesar de que haya errores de sintaxis en el código. Cuenta con detección automática del lenguaje de programación e incluso se tiene la posibilidad de incluir múltiples lenguajes en una misma instancia. 

Los usuarios cuentan con la posibilidad de añadir nuevos lenguajes de programación según la necesidad y proveer soporte de los mismos. Actualmente cuenta con soporte para 185 lenguajes de programación y 85 estilos.

En este proyecto, HighlightJs ha sido utilizado para elaborar el manual de usuario\footnote{\url{https://adrixp.github.io/aframe-charts-component/examples/bubbleChart/code.html}} facilitando así la lectura de código y pudiendo reutilizar este código de manera más clara como vemos en la Figura~\ref{fig:highlightexample}

\begin{figure}
	\centering
	\includegraphics[width=12cm, keepaspectratio]{img/highlightexample}
	\caption{Ejemplo HighlightJs}
	\label{fig:highlightexample}
\end{figure}

\section{Webpack} 
\label{sec:webpackseccion}
\begin{center}
	\includegraphics[scale=0.50]{img/webpack.png}
\end{center}

Webpack es un empaquetador de módulos estáticos. En la programación modular, los desarrolladores particionan su código en pequeños bloques que cumplen una funcionalidad concreta, y a estos se le llama módulos. Gracias a ellos, es trivial verificar, corregir y probar un programa.

El problema que nos podemos encontrar es que, si dividimos nuestro programa en muchos módulos, podemos tener problemas de escalabilidad debido a la gran cantidad de paquetes o {\textit{scripts}} que el navegador necesita descargar. Esto puede provocar, lo que comúnmente llamamos e redes, un {\textit{cuello de botella}}~\cite{littlejohn:_comnetwork}.

Por otro lado podríamos tener un único {\textit{script}} que contenga todo el código. Pero esto nos puede llevar a problemas de alcance, tamaño, legibilidad y mantenibilidad.

Resolviendo esta problemática nace Webpack. El cual nos permite escribir módulos soportando todos los formatos y además gestionar recursos. Como vemos en la Figura~\ref{fig:whatswebpack} es una herramienta que nos permite empaquetar aplicaciones {\textit{JavaScript}} modernas que contengan módulos, imágenes, fuentes, hojas de estilos.

Por último cabe destacar que Webpack se preocupa por el rendimiento y los tiempos de carga. Siempre está mejorando o agregando nuevas funciones, como la carga asíncrona, para ofrecer la mejor experiencia posible para el proyecto y los usuarios.

\begin{figure}
	\centering
	\includegraphics[width=12cm, keepaspectratio]{img/whatswebpack}
	\caption{Qué es Webpack}
	\label{fig:whatswebpack}
\end{figure}

\section{Git} 
\label{sec:gitseccion}
\begin{center}
	\includegraphics[scale=0.30]{img/git.png}
\end{center}

Como herramienta de control de versiones, en este proyecto se utiliza Git~\cite{chacon:_progit}. Este {\textit{software}} fue diseñado por Linus Torvalds (Creador del {\textit{kernel}} de {\textit{Linux}}) en 2005, cuyo propósito era crear un sistema capaz de llevar el registro de cambios en archivos de un ordenador y coordinar el trabajo que realicen varias personas simultáneamente sobre dichos ficheros.

Este software está pensado para ser utilizado de manera distribuida manteniendo un registro tanto en la computadora local como en un servidor. De esta forma cada usuario tiene una copia de los ficheros que valida contra el servidor si ha habido cambios o quisiera registrar alguno.

Gracias a esto, se consigue un gran apoyo al desarrollo mediante la rapidez para gestionar ramas y mezclado de las mismas. De hecho, en la mayoría de proyectos de desarrollo Git ha desbancado a SVN como principal controlador de versiones.

\section{Realidad Virtual} 
\label{sec:vrseccion}

Entendemos por realidad virtual~\cite{grigore:_vrtech} aquella tecnología que a través de uno o varios dispositivos nos puede general la sensación de realidad en un escenario artificial creado de manera digital. Este término nace a finales de la década de 1980 y originariamente describe cómo una persona interacciona con un entorno tridimensional (3D) artificial.

En la Figura~\ref{fig:oculus} podemos ver un ejemplo de dispositivo de realidad virtual. Por lo general, cuentan con un primer aparato que se coloca en la cabeza a la altura de los ojos para realizar una inmersión en el mundo virtual y abstraerse de la realidad convencional. Además, como vemos en la imagen, estos dispositivos cuentan con unos mandos para moverse o realizar acciones dentro de este mundo virtual.

Desde un inicio, esta tecnología ha estado orientada a la industria de los videojuegos. Pero no ha tardado en expandirse y tener aplicación en el mundo de la medicina, enseñanza, industria y turismo.

\begin{figure}
	\centering
	\includegraphics[width=12cm, keepaspectratio]{img/oculus}
	\caption{Dispositivo de Realidad Virtual}
	\label{fig:oculus}
\end{figure}

\section{OpenGL} 
\label{sec:webglseccion}
\begin{center}
	\includegraphics[scale=0.30]{img/opengl.png}
\end{center}

OpenGL~\cite{paulmartz:opengl} es una librería de gráficos de código abierto cuyo lanzamiento inicial fue en el año 1994. Define un API multilenguaje y multiplataforma para producir aplicaciones que rendericen gráficos en 2D y 3D. Esta interfaz cuenta con mas de 250 funciones para dibujar escenas tridimensionales a partir de primitivas más simples bidimensionales.

Sus aplicaciones a día de hoy va desde simuladores de vuelo hasta el desarrollo de videojuegos con una creciente comunidad que impulsa este fenómeno. Además está pensado para conseguir una mayor abstracción sobre la complejidad de interactuar con el hardware de la tarjeta gráfica ofreciendo un API único y uniforme.

En la  Figura~\ref{fig:openglshader} tenemos un ejemplo de como a partir de primitivas simples como vértices podemos ir creando distintas formas como triángulos. Cada uno de estos vértices almacena ciertos atributos como por ejemplo las coordenadas.

Por último la tarjeta gráfica procesa cada uno de estos vértices de manera individual y aplica la transformación necesaria para proyectar estos vértices en el mundo 3D en nuestra pantalla 2D. Una vez transformados lo vértices de entrada se formarán los triángulos, líneas o puntos mencionadas anteriormente como primitivas simples.

Un último paso, introducido recientemente, es el de aplicar el sombreado geométrico o {\textit{shader}}.
\begin{figure}[H]
	\centering
	\includegraphics[width=12cm, keepaspectratio]{img/openglshader}
	\caption{Ejemplo de Shader OpenGL}
	\label{fig:openglshader}
\end{figure}

\section{WebGL} 
\label{sec:webglseccion}
\begin{center}
	\includegraphics[scale=0.30]{img/webgl.png}
\end{center}

WebGL~\cite{danchilla:_webgl} o {\textit{Web Graphics Library}} es un estándar que define una API escrito en JavaScript y que implementa OpenGl  para la generación de gráficos en 3D en el navegador web. No es necesaria la instalación de un complemento o {\textit{plugin}} para los navegadores, debido a que actualmente tanto las versiones para móvil como las de escritorio cuentan con soporte OpenGL 2.0. 

Esta tecnología nace a raíz del WebVR mencionado en el apartado anterior y es en 2009 cuando se consolida como grupo de trabajo. A raíz de ello en marzo de 2011 se lanza la primera versión oficial.

La primera versión (1.0) de WebGL está basado en OpenGL 2.0 y proporciona una API para gráficos 3D. Esta, utiliza el elemento HTML5 llamado canvas o lienzo al que se accede mediante el Document Object Model (DOM). Para ello se debe definir una región dentro de nuestro HTML donde se representará la escena 3D. Solo es posible crear esta región en los navegadores web que admiten HTML5. Al ser parte del DOM nos permite interactuar de forma dinámica con otros elementos de la página.

WebGL 2.0 está basado en OpenGL 3.0 y garantiza disponibilidad de muchas extensiones opcionales de WebGL 1.0 y presenta nuevas APIs que facilitan el desarrollo.

WebGL está integrado completamente en todos los estándares web del navegador, permitiendo la aceleración de la GPU y el procesamiento de imágenes y efectos. Esta gestión automática de memoria RAM o virtual se proporciona mediante el lenguaje JavaScript.

\section{WebVR} 
\label{sec:webvrseccion}

WebVR es una API experimental escrito en Javascript en 2006. Fue iniciado como prototipo de Canvas3D por Vladimir Vukicevic en Mozilla. Este API proporciona soporte para dispositivos de realidad virtual tales como Oculus Rift, HTC Vive o Google Cardboard, en un navegador de web.

Sus principales objetivos son detectar de manera automática dispositivos de realidad virtual disponibles y obtener sus características principales, como la posición y orientación del dispositivo, para mostrar imágenes con una latencia aceptable.

Esta tecnología tiene una primera versión finalizada en 2017 donde principales compañías como Mozilla, Google y ahora Microsoft dan soporte y mantenimiento.

La API WebVR expone ciertas interfaces que permiten a las aplicaciones web incluir contenido de realidad virtual. Para ello se hace uso de WebGL, descrito en el siguiente apartado, como motor para gráficos 3D. Además permite obtener las configuraciones necesarios para la cámara y los dispositivos controladores (por ejemplo, un mando o el punto de vista).

\section{Three.js} 
\label{sec:threejsseccion}
\begin{center}
	\includegraphics[scale=0.30]{img/threejs.png}
\end{center}

Three.js\footnote{\url{https://threejs.org}} es una librería escrita en JavaScript para mostrar contenido 3D en páginas web. Nos provee la capacidad de renderizar escenas, modelos, sonido, vídeos, luces, sombras, animaciones, partículas y muchos otros tipos de visualizaciones.

No debemos confundir Three.js con WebGL. WebGL es un sistema de bajo nivel con el que podemos dibujar primitivas simples como puntos, líneas y triángulos. Three.js utiliza este motor a bajo nivel y nos permite abstraernos de su complejidad teniendo ya disponibles ciertas interfaces como escenas, luces, materiales, etc mencionadas anteriormente.

Al igual que WebGL, se utiliza el elemento canvas de HTML5 para comenzar creado una escena. En la  Figura~\ref{fig:threejscene} podemos ver la arquitectura general de como se compone dicha escena. Por un lado tenemos la figura geométrica compuesta por vértices y superficies. Esta figura geométrica puede se le puede añadir un material que está compuesta por una o varias imágenes que a su vez componen lo que conocemos por textura. Si sumamos esta figura geométrica y su material obtenemos lo que denominamos una malla. La malla, las luces y la cámara componen nuestra escena 3D.

\begin{figure}
	\centering
	\includegraphics[height=10cm,width=12cm, keepaspectratio]{img/threejscene}
	\caption{Escena Three.js}
	\label{fig:threejscene}
\end{figure}

Por último, de manera transparente para el desarrollador, Three.js llama al renderizador de WebGL para representar nuestra escena que se podrá visualizar en cualquier navegador web.

Para comprender mejor el funcionamiento o para que sirve una cámara en una escena 3D tenemos la Figura~\ref{fig:frustum}. La cámara es un punto de perspectiva desde donde se visualiza la escena 3D. En Three.js tenemos cuatro parámetros básicos para definir una cámara:

\begin{figure}
	\centering
	\includegraphics[height=7cm,width=10cm, keepaspectratio]{img/frustum}
	\caption{Ejemplo de cámara. Forma geométrica ''{\textit{frustum}}''}
	\label{fig:frustum}
\end{figure}

\begin{itemize}
	\item El ''fov'' es la abreviatura de {\textit{field of view}} o campo de visión. Es el ángulo de visuón de la cámara y se utilizan grados como medida.
	
	\item El segundo parámetro es el ''aspect''. El cual define el aspecto de visualización del lienzo o el ratio de píxeles. Por ejemplo un canvas de 400 píxeles de ancho por 200 de alto, tendría un ''aspect'' de dos.
	
	\item Por último tenemos los parámetro ''far'' y ''near'' que definen la distancia de lo que vamos a poder visualizar en la escena. Si algún objeto quedara fuera de este rango no se visualizará.
\end{itemize}


Estos cuatro ajustes definen un ''{\textit{frustum}}'', es decir, el nombre de una forma 3D en forma de pirámide con la punta cortada. Al fin y al cabo esta definición es la que utiliza la cámara para visualizar la escena.


\section{A-Frame} 
\label{sec:aframeseccion}
\begin{center}
	\includegraphics[scale=0.30]{img/aframe.jpg}
\end{center}

A-Frame\footnote{\url{https://aframe.io/}} es un {\textit{framework web}} que permite construir experiencias de realidad virtual en el navegador. Gracias a su interfaz de entidad-componente podemos visualizar WebVR en cualquier dispositivo de realidad virtual como las HTC Vive, Oculus Rift, Daydream o Samsung GearVR así como en navegadores de escritorio y móvil. Además puede ser incluso usado para realidad aumentada.

A-Frame no es solo un creador de escenas en 3D o un lenguaje de marcado. Su motor está apoyado en el {\textit{framework web}} entidad-componente, proveyendo una estructura declarativa, extensible y componible de Three.js. A-Frame nos provee un nivel más de abstracción, facilitando incluso más aún el comienzo para desarrollar en 3D que Three.js.

Esta librería, estuvo originalmente concebida por Mozilla y ahora mantenida por los co-creadores de A-Frame y Supermedium\footnote{\url{https://supermedium.com/}} el cual es un navegador web puramente diseñado para WebVR y usado con dispositivos de realidad virtual. Este proyecto de código libre cuenta con una de las mayores comunidades de Realidad Virtual.

Entre sus mayores características encontramos:

\begin{itemize}
	\item A-Frame provee de un arquetipo 3D, configuración para VR y los controles predeterminados. Sin necesidad de instalación o compilación, únicamente es necesario importar la librería con la etiqueta \textless script\textgreater\space y crear el componente \textless a-scene\textgreater.
	
	\item Como vemos en la Figura~\ref{fig:aframe_code}, se utiliza un HTML sencillo de entender y reutilizable. Es accesible para todo tipo de público, desde desarrolladores a educadores, artistas, diseñadores y niños.
	
	\begin{figure}
		\centering
		\includegraphics[width=12cm, keepaspectratio]{img/aframe_code}
		\caption{Ejemplo código HTML de A-Frame}
		\label{fig:aframe_code}
	\end{figure}
	
	\item Utiliza una arquitectura basada en entidad-componente. Es decir nos provee de una interfaz para reutilizar, declarar y acceder a objetos diseñados y optimizados de Three.js. Además, nos permite el acceso a cualquier elemento del DOM e incluso al motor de bajo nivel WebGL.
	
	\item Es una librería VR diseñada para ser multidispositivo y multiplataforma. Como se ha mencionado anteriormente es compatible con Vive, Rift, Windows Mixed Reality, Daydream, GearVR y Cardboard con soporte para todos los controladores respectivos.
	
	\item El rendimiento es otro punto fuerte de esta librería. A-Frame está optimizada desde cero para WebVR. Los componentes no manipulan el motor de diseño 3D del navegador y las actualizaciones se realizan en memoria llegando a alcanzar los 90 {\textit{fps}} en escenas con infinidad de elementos.
	
	\item La librería de A-Frame nos proporciona un poderoso elemento diseñado para ayudar al desarrollo. Este componente es el inspector de elementos que vemos en la Figura~\ref{fig:aframe_inspector} . Este inspector recuerda a la manera de crear escenas en otros motores gráficos como el de Unity3D\footnote{\url{https://unity.com/es}}. Pero la principal característica es que, gracias a él, podemos realizar cambios en la escena en vivo. Pudiendo añadir y borrar elementos e incluso actualizar los atributos de cada componente.
	
	\begin{figure}
		\centering
		\includegraphics[width=12cm, keepaspectratio]{img/aframe_inspector}
		\caption{Ejemplo del inspector de A-Frame}
		\label{fig:aframe_inspector}
	\end{figure}
	
	\item Los componenetes principales que nos proporciona A-Frame son geometrías, materiales, luces, animaciones, modelos, difusores de rayos, sombras, audio posicional, texto y soporte para la mayoría de auriculares. La comunidad además ha aportado otros como medio ambiente , el estado , los sistemas de partículas , la física , los océanos y la realidad aumentada.
	
	\item Es una librería de probada escalabilidad llegando a ser utilizada por grandes empresas como Google, Disney, Samsung, Toyota, Ford, Chevrolet, CERN, NPR. Compañías como Google, Microsoft, Oculus y Samsung han realizado contribuciones para mejorar A-Frame.
	
		
	\begin{figure}
		\centering
		\includegraphics[width=12cm, keepaspectratio]{img/aframe_example}
		\caption{Ejemplo escena de A-Frame}
		\label{fig:aframe_example}
	\end{figure}
	
\end{itemize}

En esta potente librería de VR se basa este proyecto fundamentalmente.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DISEÑO E IMPLEMENTACIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Diseño e implementación}

En este apartado se muestra el diseño e implementación de este proyecto. Se comienza describiendo la metodología utilizada y las distintas etapas por las que ha pasado el proyecto. Más adelante profundizaremos en cada una de dichas etapas, describiendo el desarrollo que se ha realizado de manera incremental para este trabajo.


\section{Metodología SCRUM} 
\label{sec:scrum}

La metodología que se ha seguido en este proyecto es una simplificación de la denominada metodología SCRUM~\cite{blokehead:scrum}. Este procedimiento se caracteriza principalmente por ser incremental y estar enfocado al desarrollo de software ágil. A diferencia de otros métodos donde se desarrolla de manera secuencial o en cascada (requisitos, diseño, implementación, verificación y mantenimiento), la metodología SCRUM permite solapar estas fases e incluso realizarlas mediante incrementos más pequeños.

El objetivo de SCRUM es aplicar de manera regular buenas prácticas para trabajar en equipo y obtener el mejor resultado y calidad posible para el proyecto. Para esto se definen un conjunto de prácticas y roles como el de SCRUM  \textit{máster} encargado del proceso asegurando su correcto uso y guiado por las distintas etapas, el \textit{product owner} el cual es el responsable de mantener el producto y asegurar la continuidad por las líneas de trabajo establecidas. Por último tenemos al equipo de desarrollo que debe ser multidisciplinar y encargado de ir cumpliendo las distintas iteraciones y tareas para sacar adelante el proyecto.

Como se ha mencionado previamente, en este proyecto se ha seguido una simplificación de la metodología SCRUM. Se han mantenido reuniones periódicas donde el tutor desempeñaba el papel de cliente y el autor el de desarrollador.

A continuación se describe brevemente cada una de las etapas o \textit{sprints} por las que ha pasado este proyecto:

\begin{itemize}
	\item \textbf{Iteración 0:} Esta es la fase previa donde se realizará un estudio de los requisitos del proyecto y las tecnologías a utilizar. La idea principal es familiarizarse con la librería A-Frame utilizando la documentación oficial y practicar mediante ejemplos básicos.
	
	\item \textbf{Iteración 1:} En esta primera etapa se tiene como objetivo crear las primeras escenas con gráficos en 3D. Para ello crearemos un repositorio de código inicial donde se va a usar nodeJS como servidor y Webpack como empaquetador de nuestra librería. Como objetivo final, se procederá a crear un primer gráfico para nuestra librería con un \textit{dataset} de ejemplo incrustado en el propio código JavaScript.
	
	\item \textbf{Iteración 2:} El segundo paso será empleado para enriquecer nuestra librería para que soporte un mayor número de gráficas. Se empezará a proporcionar un API para el uso de la librería. Además se procederá a separar la capa de datos de la aplicación para una mejor generalización.
	
	\item \textbf{Iteración 3:} En la tercera iteración se procederá a una refactorización total del código. Se utilizarán los estándares de A-Frame y crearemos un nuevo proyecto en GitHub, publicaremos nuestra librería en el repositorio de código de NodeJs.
	
	\item \textbf{Iteración 4:} En este apartado se realizará un enriquecimiento de la parametrización de nuestros gráficos pudiendo ser explotadas gracias al API proporcionado. Además se añadirán nuevos gráficos como el de tarta solicitado por la comunidad cerrando así las primeras incidencias.
	
	\item \textbf{Iteración 5:} En esta quinta y última iteración se procede a solucionar los distintos errores de funcionamiento de la librería. Se proporciona la posibilidad de una representación dinámica de los datos. Y por último se facilita la integración mediante ejemplos para ser utilizada con dispositivos de realidad virtual.
	
\end{itemize}

\section{Iteración 0. Estudio previo.} 
\label{sec:iteracion0}

En esta fase previa se comienza realizando un estudio previo de las tecnologías que vamos a utilizar en el proyecto. Debido a que se tiene un amplio conocimiento de JavaScript y HTML vamos a cumplir directamente nuestro objetivo específico de estudiar el \textit{framework} A-Frame. Para este menester, se comienza visitando la web oficial de A-Frame\footnote{\url{https://aframe.io/}} donde se puede encontrar toda la documentación\footnote{\url{https://aframe.io/docs/0.9.0/introduction/}} necesaria para comenzar a crear escenas en 3D en nuestro navegador con unos simples pasos.

Para ello se va a comenzar creando un primer proyecto HTML que llamaremos provisionalmente A-Charts. Utilizaremos el IDE WebStorm\footnote{\url{https://www.jetbrains.com/webstorm/}} de la compañía Jetbrains para comenzar con el desarrollo. Crearemos un proyecto HTML vacío que constará de los siguientes componentes: última versión de la librería de A-Frame\footnote{\url{https://aframe.io/releases/0.9.2/aframe.min.js}} mimificada, y el siguiente fichero HTML con el código que vemos a continuación.

\lstinputlisting[language=Html]{code/iteracion0-index.html} 


Como se puede ver en el código, A-Frame interpreta distintas etiquetas de marcado como:

\begin{itemize}
	\item[--] \textless a-scene\textgreater: La escena es el objeto raíz global, y todas las entidades están contenidas dentro de la escena.
	\item[--] \textless a-box\textgreater: Es una de las formas geométricas primitivas de la librería y crea formas como cajas, cubos o paredes.
	\item[--] \textless a-sphere\textgreater: Otra forma primitiva para crear una forma esférica o poliedro
	\item[--] \textless a-cylinder\textgreater: Esta etiqueta crea figuras geométricas en forma de tubo y superficies curvadas.
	\item[--] \textless a-plane\textgreater: Una primitiva más para crear superficies planas.
	\item[--] \textless a-sky\textgreater: El cielo agrega un color de fondo o una imagen de 360 ??° a una escena. Un cielo es una esfera grande con un color o textura mapeada hacia adentro.
	\item[--] \textless a-camera\textgreater: Componente que define desde qué perspectiva el usuario ve la escena
\end{itemize}


Estas etiquetas son las más basicas y el resultado podemos verlo en la siguiente Figura~\ref{fig:iteracion0}



\begin{figure}
	\centering
	\includegraphics[width=12cm, keepaspectratio]{img/iteracion0}
	\caption{Primera escena con A-Frame}
	\label{fig:iteracion0}
\end{figure}

\section{Iteración 1. Primer gráfico.} 
\label{sec:iteracion_1}

En esta primera iteración vamos a proceder a la creación de un repositorio de código en GitHub donde subiremos nuestros primeros desarrollos de la librería. se van a crear dos ramas de desarrollo, develop y master, en nuestro repositorio de git. De esta manera podremos ir desarrollando y probando distinta funcionalidad y solo subiremos a nuestra rama principal cuando tengamos el código probado y listo para producción.

Además, vamos a proceder a nuestra iniciación en el mundo con proyectos NodeJs y Webpack. Para todos estas tecnologías, el tutor de esta memoria ha proporcionado una web\footnote{\url{https://jgbarah.github.io/aframe-playground/}} con documentación y ejemplos que también han ayudado en el estudio previo a realizar.

Con esta información, se genera un nuevo proyecto llamado A-Charts con la arquitectura que vemos en la Figura~\ref{fig:arquitecturaAlpha} 

\begin{figure}
	\centering
	\includegraphics[width=8cm, keepaspectratio]{img/arquitecturaAlpha}
	\caption{Primera arquitectura del proyecto}
	\label{fig:arquitecturaAlpha}
\end{figure}

Primero se comienza aprendiendo que es Webpack y para qué se utiliza. Como se describe en el estado de arte, esta teconología es utilizada para empaquetar módulos estáticos. En la programación modular, los desarrolladores particionan su código en pequeños bloques que cumplen una funcionalidad concreta, y a estos se le llama módulos. 

Por tanto, para empezar a usar esta herramienta se crea el fichero de configuración llamado \textit{webpack.config.js}:

\lstinputlisting[language=JavaScript]{code/iteracion1-webpack.js}

En esta configuración se establece que nuestro código, estará en \textit{src/acharts.js} y su salida bundle.js en el directorio dist. Además se le especifican donde tendremos nuestros módulos JavaScript así como el transpilador a utilizar, en este caso babel y el módulo de HTML. Por otro lado se utilizará el plugin de HTML para webpack y definir nuestro template.

Por otro lado se comienza con la configuración del servidor web NodeJs. Para ello es necesario un fichero llamado package.json donde se especifican los metadatos del proyecto como nombre, descripción, versión, licencia, repositorio, etc.

A continuación se describen las líneas del fichero package.json que detallan las acciones para las etapas de desarrollo y despliegue.
\begin{lstlisting}[language=json,firstnumber=1]
{
	"scripts": {
		"dev": "webpack --mode development",
		"build": "webpack --mode production",
		"watch": "webpack --mode development --watch",
		"test": "echo \"Error: no test specified\" && exit 1",
		"start": "webpack-dev-server --mode development --content-base dist/",
		"clean": "rm -r dist/*",
		"cleanbuild": "rm -r dist/* && webpack --mode production"
	}	
}
\end{lstlisting} 

Y por último las dependecias del proyecto también incluidas en nuestro fichero package.json. Node automáticamente buscará estas dependencias en el repositorio de npm y las guardará en el directorio \textit{\texttt{node\_modules}} .

\begin{lstlisting}[language=json,firstnumber=1]
{
	"devDependencies": {
		"babel-core": "^6.26.0",
		"babel-loader": "^7.1.4",
		"babel-preset-env": "^1.6.1",
		"copy-webpack-plugin": "^4.5.1",
		"file-loader": "^1.1.11",
		"html-loader": "^0.5.5",
		"html-webpack-plugin": "^3.0.6",
		"webpack": "^4.1.1",
		"webpack-cli": "^2.0.11",
		"webpack-dev-server": "^3.1.1"
	},
	"dependencies": {
		"aframe": "^0.8.2"
	}	
}
\end{lstlisting} 

Una vez configurado el proyecto comenzaremos a escribir nuestro template HTML.

\lstinputlisting[language=Html, title= template.html]{code/iteracion1-template.html}

Como se ve en el código HTML del template, se definen varias etiquetas que el motor de A-Frame interpreta. En el apartado \textit{Iteración 0}, se explican varias de las etiquetas básicas utilizadas en el \textit{template.html} tales como \textless a-scene\textgreater, \textless a-sky\textgreater, \textless a-light\textgreater y \textless a-camera\textgreater. 

Además se añaden una entidad genéricas de A-Frame con la etiqueta \textless a-entity\textgreater. Estas entidades, son componentes genéricos listos para proporcionar una apariencia, comportamiento y funcionalidad determinada. Dichas cualidades se generan mediante código JavaScript completando estos componentes.
Por tanto se puede decir que el objetivo de esta librería sería,  mediante estas entidades genéricas, dotar de a nuestro HTML de los gráficos que se requieran.

Como se puede ver, la etiqueta \textless a-entity\textgreater tiene un identificador para generar un componente llamado \textit{axis}, el cual representará los ejes x,y,z en 3D. Esta definición, entre otras, quedará reflejada en el fichero \textit{src/acharts.js} visto en la Figura 4.2. detallado a continuación por partes.

Primero se comienza importando la librería de A-Frame.

\lstinputlisting[language=JavaScript, title= Importación librería A-Frame]{code/iteracion1-import.js}

Se definen los puntos que tendrá nuestro gráfico de barras en tres dimensiones x,y,z. Además se definen los atributos color y altura.
\lstinputlisting[language=json, title= JSON para representar el  gráfico]{code/iteracion1-points.json}

A continuación se define la función encargada de generar nuestro gráfico de barras una vez el DOM haya sido cargado. Lo primero de todo, almacenamos en la variable \textit{scene} la entidad a-scene de A-Frame. Recorremos todos los puntos previamente definidos en la variable \textit{barPlotItems} y por cada punto, creamos una nueva entidad con el atributo \textit{barplot}. Esto quiere decir que cada entidad tomará el comportamiento, funcionalidad y estilo que hayamos registrado en el componente de A-Frame \textit{barplot}. Además a cada nueva entidad se le pasan como argumento una lista de valores definidos en el esquema del componente que veremos a continuación. Por último, añadimos cada nueva entidad a la escena con la función \textit{appendChild}.
\clearpage

\lstinputlisting[language=JavaScript, title= Función ejecutada al cargarse el DOM]{code/iteracion1-loader.js}

En este siguiente paso vamos a registrar nuestro componente \textit{barplot} mediante la función \textit{registerComponent} de A-Frame. A esta función se le pasa como argumento el nombre, el cual será usado como atributo HTML en la representación del componente en el DOM. Luego se añade la definición del componente, que es un objeto JavaScript de métodos y propiedades. Estos métodos pueden definir el manejo del ciclo de vida del componente.

En este caso, la definición del componente constará de la posición, el color, la altura, el tamaño y el tipo. Este último nos servirá en un futuro para que nuestro componente no sólo sea un gráfico de barras sino que pueda implementar distintos tipos de gráficos en función del esquema que se le pase.

Después, se implementa la función \textit{update} proporcionada por el core de A-Frame. Esta función es ejecutada cuando se modifica alguna propiedad de dicho componente (para actualizar el gráfico dinámicamente sin necesidad de refrescar la página web) o en el inicio del ciclo de vida del componente (después de la función \textit{init}) como es el caso.

Como vemos en el código, se comprueba que el tipo de gráfico sea \textit{cylinder}, es decir una barra cilíndrica, y si se cumple dicha condición, se rellenan todos los parámetros del esquema gracias al método \textit{self.data} donde tenemos almacenados todos los datos introducidos anteriormente. 


\lstinputlisting[language=JavaScript, title= Definición del componente barplot]{code/iteracion1-barplot.js}

Por último, se registra el componente \textit{axis}. En este caso, se define en el esquema del componente únicamente el color. Además se implementa nuevamente la función \textit{update}.

Dentro de esta función se generan el elemento \textit{line} de A-Frame varias veces. Se crean, en concreto, tres líneas por cada eje de coordenadas (x,y,z) con una longitud de diez unidades. Luego, por cada eje de coordenadas y de una en una unidad, se generan los \textit{ticks} (más líneas de longitud 0.4 unidades) para ayudar en la interpretación de la posición del gráfico final.

El componente \textit{line} dibuja una línea dada una coordenada de inicio y otra final. Como se expone anteriormente en el punto 3. Estado del arte, este componente lo hereda A-Frame de la librería Three.js y por tanto se tiene a disposición para su uso en esta librería.

\lstinputlisting[language=JavaScript, title= Definición del componente barplot]{code/iteracion1-axis.js}


Cuando arrancamos el proyecto con el comando \textit{start} definido en el fichero \textit{package.json} se obtiene como resultado el primer gráfico que se puede ver en la Figura~\ref{fig:iteracion1-resultado} 


\begin{figure}
	\centering
	\includegraphics[width=12cm, keepaspectratio]{img/iteracion1-resultado}
	\caption{Iteración 1: Resultado}
	\label{fig:iteracion1-resultado}
\end{figure} 

\clearpage

\section[Iteración 2. Visualizaciones y separación de la capa de datos]{Iteración 2. Enriquecimiento de la librería y separación de la capa de datos.}
\label{sec:iteracion_2}

En esta segunda iteración tenemos como objetivo añadir más tipos de gráficos a nuestra librería. Cada gráfico será un nuevo componente que registraremos en A-Frame como se ha mostrado en la primera iteración.

Por otro lado vamos a separar los datos, los cuales forman puntos en el espacio tridimiensional, del código donde se generan las representaciones en sí. Para ello se crea uno o varios ficheros JSON con los datos y se especificará en el componente la ruta del fichero donde obtener estos datos.

Respecto al template HTML mostrado a continuación y al visto en la primera iteración se aprecian varios cambios. Para empezar se ha eliminado la entidad \textit{axis} ya que, como veremos más adelante, cada gráfico llamará al componente \textit{axis}. Por tanto, solo es necesario declarar una entidad de A-Frame teniendo como atributo el nombre del componente. 
\lstinputlisting[language=Html, title= template.html]{code/iteracion2-template.html}
Como se ve en la imagen \textit{template.html}, dentro del atributo \textit{bubble\_chart} añadimos cuatro propiedades: \textit{datapoints}, \textit{size}, \textit{position} y \textit{color}. Estas propiedades estan descritas en el esquema del componente que veremos a continuación.


En esta versión de la librería registraremos tres tipos de componentes, uno por cada tipo de gráfico. Solo necesitaremos poner el nombre del componente como atributo para que la librería de A-Frame renderice nuestro gráfico tal y como hemos visto en el código HTML anterior.

Los tres componentes que se desarrollan son \textit{bubble\_chart} (gráfico de burbujas), \textit{bar\_chart}(gráfico de barras cilíndricas o cúbicas) y \textit{line\_chart}(Para el gráfico de líneas).
Todos ellos siguen la siguiente estructura de código:
\begin{itemize}
	\item Registro del componente y definición del esquema.
	
	\lstinputlisting[language=JavaScript, title= Registro del componente y esquema]{code/iteracion2-schema.js}
	En este esquema se puede ver la concordancia del HTML visto anteriormente y el componente. Vemos que se definen las propiedades y el tipo de dato. La propiedad más importante y novedosa en esta iteración es la de \textit{datapoints}, a la cual se le especifica que sea de tipo \textit{asset} (activo o recurso). Esto quiere decir que vamos a poder pasar al componente una ruta donde tengamos nuestro fichero JSON con los datos del gráfico.
	
	La única diferencia de esquema entre los tres componentes es el atributo \textit{type}. Este atributo se usa únicamente en el componente \textit{bar\_chart} para especificar si queremos un gráfico con barras cilíndricas o cúbicas. En posteriores iteraciones se usará este concepto para unificar los componentes en uno siguiendo los estándares de A-Frame.

	\item Definición de la función \textit{init} y \textit{update}.
	\lstinputlisting[language=JavaScript, title= Funciones init y update]{code/iteracion2-init-update.js}
	
	La función \textit{init} es llamada al inicio del ciclo de vida del componente. Sirve para inicializar ciertas variables del componentes o funciones \textit{listener}. En este caso, se inicializa la función \textit{FileLoader}
	que nos provee Threejs encargada de cargar en memoria cualquier tipo de fichero.
	
	Por otro lado, la función \textit{update} es llamada después de la función \textit{init} en el ciclo de vida del componente. Además tiene la peculiaridad de ser invocada cada vez que se cambie algún atributo, por ello realizamos ciertas comprobaciones en el código. La primera de ellas, es comparar si el fichero de datos que se ha modificado es igual que el que teníamos cargado con la función \textit{deepEqual} de A-Frame. Si son iguales se ignora el fichero y no se realiza ningún trabajo.
	En la segunda comprobación volvemos a comprobar que los datos en JSON son efectivamente distintos y si el fichero contiene datos válidos. Si es así, invocamos a la función \textit{onDataLoaded} que hemos definido en nuestro componente. Esta función no es nativa de A-Frame, si no que ha sido implementada en este proyecto y es donde se desarrolla toda la lógica de nuestro componente.
	
	\item Definición de la función \textit{onDataLoaded}
	\lstinputlisting[language=JavaScript, title= Función onDataLoaded]{code/iteracion2-ondataloaded.js}
	Finalmente, se define la función \textit{onDataLoaded} cuyo argumento \textit{file} es el fichero de datos.
	Primero se crea el componente genérico \textit{axis} que utilizan todos los gráficos pasándole como esquema el color y la posición de los ejes.
	Seguidamente parseamos el fichero con la función JavaScript JSON.parse. Gracias a ella podemos recorrer cada punto del gráfico en un bucle.
	Por cada elemento de los datos del JSON se crea una entidad de A-Frame, en este caso \textless a-sphere\textgreater. Los atributos vienen dados por el propio fichero de datos y el esquema del componente. Además se le añade una pequeña función para que cuando pasemos el ratón por encima de cada elemento, este se haga mayor.
	
\end{itemize}

Cabe destacar que el componente \textit{axis} ha sido refactorizado respecto a la primera iteración. En este caso se ha subdividido en dos componentes, uno de ellos genérico donde se recorren los ejes x, y, z y el otro donde se crean las líneas y ticks de los propios ejes quedando de la siguiente manera:

\lstinputlisting[language=JavaScript, title= Componente axis]{code/iteracion2-axis.js}

Por último, se ha añadido a modo de ejemplo para uso de esta librería un menú de opciones. Si se selecciona alguna de estas opciones se sustituye el gráfico anterior por el seleccionado.

Para esto se han seguido los siguientes pasos:

\begin{itemize}
	\item Se añade al fichero \textit{webpack.config.js} las siguiente configuración para empaquetar CSS y JSON.	
	\lstinputlisting[language=JavaScript, title= webpack.config.js CSS y JSON]{code/iteracion2-webpack.js}
	
	\item Añadimos la dependencia \textit{css-loader} al fichero  \textit{package.json}.	
	\lstinputlisting[language=Json, title= Dependencia para package.json]{code/iteracion2-package.json}
		
	\item Código HTML para el menú de opciones
	\lstinputlisting[language=html, title= HTML menú de opciones]{code/iteracion2-menu.html}
	
	\item El CSS para el menú de opciones simplemente hace que el elemento con la clase \textit{div-opt} se posicione arriba a la izquierda de la web.
	
	\item Código JavaScript para el menú de opciones
	\lstinputlisting[language=JavaScript, title= JS menú de opciones]{code/iteracion2-menu.js}
	
\end{itemize}

Cuando arrancamos el proyecto, nuevamente con el comando \textit{start} definido en el fichero \textit{package.json}, se obtiene como resultado las Figuras~\ref{fig:iteracion2-resultado} y~\ref{fig:iteracion2-resultadob}.
\begin{figure}
	\centering
	\includegraphics[width=12cm]{img/iteracion2-resultado}
	\caption{Iteración 2: Resultado Gráfico de Barras}
	\label{fig:iteracion2-resultado}
\end{figure}
\begin{figure}
	\centering
	\includegraphics[width=12cm]{img/iteracion2-resultadob}
	\caption{Iteración 2: Resultado Gráfico de burbujas}
	\label{fig:iteracion2-resultadob}
\end{figure}
\clearpage

\section[Iteración 3. Refactorización y estandarización del módulo.]{Iteración 3. Refactorización y estandarización del \\módulo.} 
\label{sec:iteracion_3}

En esta iteración, el objetivo es publicar nuestro componente en la comunidad de A-Frame. Para ello seguimos las instrucciones de A-Frame Registry\footnote{\url{https://github.com/aframevr/aframe-registry}} donde debemos seguir una serie de pasos para cumplir con las \textit{best practices}.

Gracias a estas medidas tendremos nuestro componente correctamente versionado, publicado en varios repositorios de código listo para ser utilizado por terceros e incluso permitiendo la contribución de otros desarrolladores. Se creará un proyecto de cero donde integraremos nuestro antiguo componente siguiendo los siguientes pasos:

\begin{itemize}
	
	\item[--] En primer lugar se utiliza la herramienta \textit{angle}\footnote{\url{https://github.com/ngokevin/angle}}, la cual permite crear un proyecto de cero por línea de comando (Figura~\ref{fig:iteracion3-angle}). Se genera un componente con una arquitectura genérica (Figura~\ref{fig:iteracion3-arquitectura}).	
		
	\item[--] Se publica el componente en npm, el repositorio de paquetes de nodeJs, mediante el comando \textit{npm publish}. Para ello es necesario tener instalado npm en nuestro sistema y crearse una cuenta gratuita en la web oficial \footnote{\url{https://www.npmjs.com/}}
	
	\item[--] Se publica el componente en GitHub, un repositorio online de código. Para ello es necesario tener instalado git en nuestro sistema y crearse una cuenta gratuita en la web oficial \footnote{\url{https://github.com/}}. Una vez creado el proyecto en la web, debemos ir mediante línea de comandos donde tenemos nuestro proyecto y ejecutar \textit{git init}, \textit{git commit} y \textit{git push}.	
	
	\item[--] Se añade documentación sobre las propiedades del componente y una página de ejemplo de uso de la librería. Todo ello se puede consultar en la sección de Resultados. 
	
	\item[--] Se debe publicar una página web con ejemplos. Se propone \textit{GitHub Pages} la cual utilizamos para ver nuestro resultado\footnote{\url{https://adrixp.github.io/aframe-charts-component/}}.
	
	\item[--] Se debe añadir un enlace desde dicha página web al repositorio de GitHub.
	
	\item[--] Debe tener sentido en el contexto de una aplicación WebVR.
	
	\item[--] Debe incluir una imagen de vista previa o GIF en el archivo README.
	
	\item[--] Deberá seguir semver\footnote{\url{https://semver.org/}} en su esquema de versión de componente, reflejando la última versión estable de A-Frame.
	
	\item[--] Se debe auto registrar el componente con la función \textit{AFRAME.registerComponent}. En este último punto aprovechamos para realizar una refactorización del código. Nuestro template HTML queda de la siguiente manera:
	
	\lstinputlisting[language=html, title= Iteración 3: Template HTML]{code/iteracion3-template.html}
	
	Como se puede ver únicamente se instancia una entidad de A-Frame con el atributo \textit{charts}. Además, se utilizan dos propiedades, una donde se le indica la ruta del fichero de datos y el tipo de gráfico a representar.
	
	En cuanto al código JavaScript, únicamente registramos un componente llamado \textit{charts}. 
	
	\lstinputlisting[language=JavaScript, title= Iteración 3: Componente Charts]{code/iteracion3-component.js}
	
	Como vemos en su esquema, únicamente tendremos por ahora dos propiedades. La propiedad \textit{type} nos indica el tipo de gráfico que se va a generar, y en base a dicho tipo se selecciona una función u otra como la que vemos a continuación:
	
	\lstinputlisting[language=JavaScript, title= Iteración 3: Función para generar Gráfico Burbujas]{code/iteracion3-chart-function.js}
	
	Finalmente, el eje del gráfico también a recibido una refactorización importante de código quedando de la siguiente manera:
	
	\lstinputlisting[language=JavaScript, title= Iteración 3: Función para generar ejes]{code/iteracion3-axis.js}

\end{itemize}

\begin{figure}
	\centering
	\includegraphics[width=16cm]{img/angle}
	\caption{Iteración 3: Inicializar proyecto con Angle}
	\label{fig:iteracion3-angle}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=8cm]{img/iteracion3-arquitectura}
	\caption{Iteración 3: Nueva Arquitectura}
	\label{fig:iteracion3-arquitectura}
\end{figure}

El resultado final es un único componente, cuyo código es mucho más limpio y nos vale para generar distintos tipos de gráficos. Además, cumple con todas las recomendaciones de A-Frame. Cabe destacar que se ha eliminado el gráfico de líneas debido a que visualmente no aporta información sino confusión.


\section[Iteración 4. API y Resolución de peticiones de la comunidad.]{Iteración 4. Poblamiento de funcionalidad de la API. Resolución de peticiones de la comunidad.} 
\label{sec:iteracion_4}

En esta cuarta iteración se tiene como objetivo enriquecer el API de la librería. Para ello se aumentará el número de propiedades del esquema de nuestro componente y se adaptarán las distintas funciones para que todos los gráficos disfruten de dicha operatividad.

Por otro lado, se irá actualizando la documentación del componente así como su página de ejemplo y casos de uso.

Finalmente, gracias a la publicación del componente en la comunidad se recibe la petición para añadir nuevos gráficos como el gráfico de tarta quedando implementado al final de la iteración.
\newline

Para aumentar dicha funcionalidad, se comienza actualizando el esquema del componente. En esta iteración se quiere dotar a los ejes x, y, z de un mayor protagonismo ya que ayuda a la hora de obtener información del gráfico. Por ello el esquema del componente queda de la siguiente manera:

\lstinputlisting[language=JavaScript, title= Iteración 4: Esquema del componente]{code/iteracion4-schema.js}

La descripción de la funcionalidad de estos nuevos parámetros es la siguiente:

\begin{itemize}
	
	\item \textbf{axis\_position:} Posición de los ejes en las coordenadas tridimensionales. Es posible que en función de los datos el usuario prefiera tener los ejes en una u otra posición. Por defecto están en (0,0,0).
	
	\item \textbf{axis\_color:} Color de los ejes. El valor que se le pasa es un \textit{string} con el valor que se le daría al CSS de cualquier elemento HTML. El valor puede ser el color en inglés o códigos de color Hexadecimal, RGB y HSL. 
	
	\item \textbf{axis\_length:} Longitud de los ejes. Por defecto, si no se le pasa ningún valor los ejes serán adaptativos. Es decir, lo ejes por defecto tienen la longitud x,y,z del punto que mayor valor tenga en cada eje de coordenada. 
	
	\item \textbf{axis\_negative:} Opción para mostrar los ejes en las coordenadas x,y,z negativos.
	
	Para implementar estas dos últimas propiedades se utiliza la siguiente comprobación en el código y una función que recorre los puntos para obtener el mayor de todos en cada eje.
	
	\lstinputlisting[language=JavaScript, title= Iteración 4: Ejes adaptativos y negativos]{code/iteracion4-axis-adaptive.js}
	
	Como vemos se comprueba si la longitud de los ejes es cero o si se quieren ejes negativos. Después recorremos todos los datos para devolver un objeto que posteriormente se utiliza en la generación de los ejes de coordenadas.
	
	\item \textbf{axis\_tick\_separation:} Separación de los \textit{ticks} de los ejes. Por defecto será de una unidad.
	
	\item \textbf{axis\_tick\_length:} Longitud de los \textit{ticks}.
	
	\item \textbf{axis\_tick\_color:} Color de los ticks	
	
	\item \textbf{axis\_grid:} Esta opción permite generar una rejilla por cada plano que forman los ejes x,y,z. Esta rejilla ayuda a la hora de interpretar los datos representados
	
	\item \textbf{axis\_grid\_3D} En este caso, se genera una rejilla por cada punto de cada eje tridimensional. Añade mayor precisión que el punto anterior. Por contra genera muchas líneas y puede generar, en algún caso, confusión.

	La función que genera nuestros ejes quedaría de la siguiente manera:
	
	\lstinputlisting[language=JavaScript, title= Iteración 4: Nueva generación de ejes]{code/iteracion4-axis.js}
	
	Como se puede ver, primero se inicializan todas las propiedades tales como color, longitud etc. tanto de los ejes como de los \textit{ticks}. Seguidamente, se generan dichos ejes en función de la posición y de si se requiere que tomen valores negativos o no. Por último, se utiliza esto mismo para generar cada \textit{tick} de cada eje. Teniendo en cuenta su longitud e intervalos.
	
\end{itemize}

Una vez llegado a este punto se recibe la petición por parte de un miembro de la comunidad de A-Frame de incluir en la librería un gráfico de tarta\footnote{\url{https://github.com/adrixp/aframe-charts-component/issues/1}}. Por ello se decide aplazar otras propiedades definidas en el \textit{roadmap} de esta iteracion y se pospone al final de la misma. Estas nuevas funcionalidades serían las de incluir numeración en los ejes y color y tamaño de los mismos.

En un estudio previo se observa que la implementación del gráfico de tartas y el gráfico con forma de \textit{donut} siguen un desarrollo muy parecido, por lo que se decide añadir ambos.

Primero se comienza añadiendo dos nuevas propiedades al esquema del componente

\lstinputlisting[language=JavaScript, title= Iteración 4: Nuevas propiedades:  gráfico de tarta]{code/iteracion4-schema-pie.js}

En estas propiedades se define el radio del gráfico de tartas, es decir, el tamaño que tendrá. Además se permite elegir si se quiere en forma de \textit{donut} o no.

En cuanto al código, antes de llamar a la función que genera las partes del gráfico se realizan ciertas operaciones y comprobaciones.

\lstinputlisting[language=JavaScript, title= Iteración 4: Gráfico de tarta: Inicialización]{code/iteracion4-pie-check.js}

Primero se necesita calcular el valor total de todos los puntos a representar. Para ello se recorre en un bucle y se añade a la variable \textit{pie\_total\_value}. Acto seguido se calcula el ángulo que tendrá cada valor a representar. Para ello se utiliza la siguiente fórmula:

\[angulo = \frac{360 * valorpunto}{valortotal}\]

Por último incrementamos el ángulo inicial para el siguiente punto y llamamos a la función que se ve a continuación:

\lstinputlisting[language=JavaScript, title= Iteración 4: Funcíon gráfico de tarta]{code/iteracion4-pie-function.js}

Como se puede observar, esta función recibe cuatro argumentos. El punto de donde se toma el color, ángulo de inicio, ángulo de fin y el radio. Se utiliza la entidad pura \textless a-cylinder\textgreater de A-Frame y gracias a los atributos \textit{theta-start} y \textit{theta-end} se genera nuestro trozo de tarta. Para el gráfico en forma de \textit{donut} se sigue el mismo procedimiento. Lo único que cambia, es que se utiliza el elemento toroide de A-Frame llamado \textless a-torus\textgreater con las propiedades \textit{rotation} y \textit{arc} para los ángulos de inicio y fin. Podemos ver el resultado en la Figura~\ref{fig:iteracion4-result}.

Finalmente, se decide implementar las últimas propiedades para esta iteración. Nuevamente se quiere aumentar la funcionalidad y legibilidad de los ejes ya que aportará bastante información del gráfico. Por ello se decide añadir numeración en los ejes tridimensionales y que se permita elegir el color y tamaño.

Para este menester, se utilizará el elemento \textless a-text\textgreater de A-Frame como veremos a continuación.

Como siempre, se comienza añadiendo al esquema las nuevas propiedades que hacen que el componente sea totalmente configurable para el usuario y pueda utilizar las herramientas que necesite para cada caso de uso.

\lstinputlisting[language=JavaScript, title= Iteración 4: Esquema texto de los ejes]{code/iteracion4-schema-axis-text.js}

Como se observa, simplemente se añade si se quiere incluir texto, su color y el tamaño. En cuanto al código, se modifica la función \textit{generateAxis} para incluir el texto de la siguiente manera:

\lstinputlisting[language=JavaScript, title= Iteración 4: Código para generar el texto de los ejes.]{code/iteracion4-axis-text.js}

Finalmente, por cada tick de cada eje tridimensional se añade el valor correspondiente redondeado con la función \textit{Math.round}. Se puede ver el resultado en la Figura~\ref{fig:iteracion4-result}.


\begin{figure}[H]
	\centering
	\includegraphics[width=16cm]{img/iteracion4-result}
	\caption{Iteración 4: Resultado}
	\label{fig:iteracion4-result}
\end{figure}
\clearpage

\section[Iteración 5. Leyenda, fuentes de datos y dispositivos VR.]{Iteración 5. Leyenda y pop-up, consumo de otras fuentes de datos y adaptación para dispositivos de VR.} 
\label{sec:iteracion_5}

En esta última iteración, se tiene como objetivo seguir aumentando la información proporcionada por los gráficos mediante la implementación de una leyenda y de un panel informativo o \textit{pop-up}.

Por otro lado, se desarrollará un nuevo componente que nos permitirá cambiar los datos del gráfico de manera dinámica con un solo \textit{click}. Además, se habilitará en la librería la opción de consumir de otras fuentes de datos. Hasta ahora se tenía la opción de incluirlos mediante ficheros JSON, pero para poder utilizar la librería de manera más versátil se considera importante este desarrollo.

Por último, cumpliendo con otro de los objetivos más importantes, se dotará de un módulo de ejemplo para el uso de la librería con dispositivos de realidad virtual.
\newline

Primero se comienza con el desarrollo del \textit{pop-up}. Esta funcionalidad se encarga de mostrar un pequeño recuadro encima de cada punto tridimensional. Gracias a ello, pasando el cursor por cada punto se mostrará dicha información. Para ello añadimos al esquema de nuestro componente la siguiente propiedad:

\lstinputlisting[language=JavaScript, title= Iteración 5: Propiedad del esquema para el pop-up]{code/iteracion5-schema-popup.js}

Esta propiedad únicamente nos indica si queremos que se muestre o no el \textit{pop-up}. Además solo se podrá mostrar para gráficos que no sean del tipo tarta.
Por cada punto, utilizamos una función que escucha eventos. Es decir, si se detecta que el cursor está sobre un punto en cuestión se llamará a la función, y si sale del espacio que ocupa dicho punto llamará a otra para dejar de mostrar el \textit{pop-up}.

\lstinputlisting[language=JavaScript, title= Iteración 5: Funciones que escuchan eventos para mostrar u ocultar el pop-up]{code/iteracion5-listener-popup.js}

A continuación se puede ver la función que genera el elemento \textit{pop-up}. Simplemente se crea la entidad plano (nativa de A-Frame) con un tamaño predefinido y un texto con la información.

\lstinputlisting[language=JavaScript, title= Iteración 5: Código para generar el pop-up]{code/iteracion5-code-popup.js}

Por último, si se cumple la condición de mostrar el \textit{pop-up} llamamos a la función \textit{generatePopUp} la cual simplemente genera un plano con la información del punto. Se puede ver el resultado en la Figura~\ref{fig:iteracion5-popup}.

\begin{figure}[H]
	\centering
	\includegraphics[width=12cm, keepaspectratio]{img/iteracion5-popup}
	\caption{Iteración 5: Pop-up}
	\label{fig:iteracion5-popup}
\end{figure}

El siguiente objetivo para esta iteración es incluir una leyenda para gráficos de tipo tarta. Para ello se sigue una estrategia similar que para el \textit{pop-up}. Se comienza añadiendo varias propiedades al esquema del componente.

\lstinputlisting[language=JavaScript, title= Iteración 5: Propiedad del esquema para la leyenda]{code/iteracion5-schema-legend.js}

En este caso se usan cuatro propiedades. La primera, \textit{show\_legend\_info}, se utiliza para mostrar o no la leyenda. Las otras propiedades son para establecer la posición y rotación. Al ser un plano en el espacio, se facilita al usuario el poder colocarla donde necesite. Además se da la opción de utilizar un título para la leyenda, que por defecto es 'Leyenda'. En contraposición con el \textit{pop-up} se da una mayor parametrización debido a que el \textit{pop-up} hereda estos parámetros de sus puntos mientras que la leyenda no.

En cuanto al código, se utilizan cuatro funciones para generarla:

\lstinputlisting[language=JavaScript, title= Iteración 5: Funciones para generar la leyenda]{code/iteracion5-code-legend.js}

Primero obtenemos una recopilación de las propiedades que hemos establecido en el esquema. Seguidamente se genera el título de la leyenda y una entrada de texto para cada dato del gráfico. Por otro lado, se quiere mostrar de manera destacada el punto donde se tenga el cursor. Para ello, de la misma manera que se hizo para el \textit{pop-up} se utilizan funciones que escuchen eventos. De esta manera si se selecciona un punto se destaca dicho texto para una mejor interpretación de los datos por parte del usuario. 

A continuación vemos el código utilizado para generar lo comentado anteriormente:

\lstinputlisting[language=JavaScript, title= Iteración 5: Código para generar la leyenda]{code/iteracion5-codemore-legend.js}


En la Figura~\ref{fig:iteracion5-legend} se observa el resultado final.

\begin{figure}[H]
	\centering
	\includegraphics[width=14cm]{img/iteracion5-legend}
	\caption{Iteración 5: Leyenda}
	\label{fig:iteracion5-legend}
\end{figure}

Por otro lado, dado que A-Frame permite cambiar los componentes de manera dinámica mediante la función \textit{update}, se quiere añadir una nueva funcionalidad para facilitar al usuario la tarea de cambiar los datos de los gráficos de manera activa.

Para este menester, se añade otro tipo de gráfico llamado \textit{totem} cuya función no es otra que mostrar distintos ficheros de datos en un plano y si el usuario los selecciona cambien los gráficos de manera dinámica.

Se comienza añadiendo al esquema del componente dos nuevas propiedades que se ven a continuación:

\lstinputlisting[language=JavaScript, title= Iteración 5: Función para generar el totem]{code/iteracion5-schema-totem.js}

La propiedad \textit{entity\_id\_list} será una lista de identificadores proporcionada por el usuario para cada \textit{entity} de A-Frame que se añada en el HTML. Por otro lado, la propiedad \textit{dataPoints\_list} provee de un listado de ficheros. Por tanto, cuando el usuario seleccione un fichero de la lista de ficheros proporcionada y gracias a la lista de identificadores, podremos llamar a la función \textit{update} de cada entidad pasándole los nuevos datos y que se refresque de manera dinámica.

Podemos observar en el siguiente fragmento de código, como en la función \textit{update} se llama a la función \textit{generateTotem} solo si el tipo de gráfico es \textit{totem} y además no se le han pasado un fichero de datos debido a que no es un gráfico normal y, como se ha mencionado anteriormente, recibe un listado de ficheros y un listado de identificadores.

\lstinputlisting[language=JavaScript, title= Iteración 5: Propiedades del esquema para el totem]{code/iteracion5-update-totem.js}

Por último, se procede a explicar como se construye el \textit{totem} mediante la función \textit{generateTotem} y la subfunción \textit{generateTotemSlice}. 

\lstinputlisting[language=JavaScript, title= Iteración 5: Funciones generateTotem y generateTotemSlice]{code/iteracion5-totem.js}

Como se ve en la función \textit{generateTotem}, por cada fichero de datos de la lista de archivos se genera lo que se denomina un \textit{totem slice}. Esta porción de totem, no es más que un plano con el nombre del fichero al que se le asigna una función que escucha el evento \textit{click}. Cada vez que se haga un \textit{click}, se recopilan todos los identificadores de los gráficos y se le asigna el nuevo fichero de datos seleccionado. A-Frame es el encargado de llamar a la función \textit{update} de cada gráfico cambiando así sus datos de manera dinámica.
\newline

A continuación y relacionado con el punto anterior para la carga dinámica de datos, uno de los últimos cambios que se han realizado en la librería es la posibilidad de obtener los datos con llamadas AJAX y no únicamente con ficheros JSON. Hoy en día, en cualquier entorno o aplicación web, lo común es obtener los datos mediante llamadas AJAX en incluso ir actualizando los mismos con dichas llamadas. Por ello, se ha dotado a la librería de esta funcionalidad. Gracias a  podrá ser utilizada con mayor versatilidad en cualquier aplicación web.

A continuación se muestra la parte de código encargada de gestionar ficheros u objetos de datos provenientes de llamadas AJAX o variables:

\lstinputlisting[language=JavaScript, title= Iteración 5: Código gestión de Objetos o ficheros]{code/iteracion5-ajax.js}

Como se puede ver, simplemente se comprueba el tipo de objeto que se le pasa a la función update de A-Frame. Si es un JSON no recibe tratamiento, si es un String se parsea a JSON y si es un fichero se obtienen los datos con la función loader de ThreeJS descrita anteriormente.
\newline

Finalmente y como último punto, se provee de un ejemplo para la visualización de la librería con dispositivos de Realidad Virtual. Para ello simplemente es necesario añadir a nuestro códgio HTML las siguientes propiedades que nos ofrece la librería de A-Frame.

\lstinputlisting[language=HTML, title= Iteración 5: Código para integración con dispositivos VR]{code/iteracion5-vr-control.html}

Como se ha podido ver, añadiendo la entidad \textit{laser-control} de A-Frame dotamos al dispositivo VR del control necesario para poder interactuar con la librería. Además para facilitar la visualización, se le añade la entidad \textit{movement-control} con el parámetro \textit{fly} y valor \textit{true}. Esto nos permite que la cámara se mueva a la par del movimiento del usuario que utilice el dispositivo de realidad virtual.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% RESULTADOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Resultados}

\section{Arquitectura general} 
\label{sec:arquitectura}

En esta sección se explica la foto final de la arquitectura con la que se ha desarrollado la librería. Como se ha mencionado previamente, gracias a la herramienta \textit{angle} de A-Frame se genera un arquetipo con los ficheros necesarios para desarrollar un componente. En la Figura~\ref{fig:resultados-arquitectura} se observa el resultado que se describirá a continuación.

\begin{itemize}
	\item \textbf{package.json:} Este fichero, tal y como se ha mencionado anteriormente en esta memoria, contiene los metadatos del proyecto. Además, se utiliza como gestor de dependencias y es el encargado de definir las etapas de desarrollo, despliegue, tests, etc.
	
	\item \textbf{index.js:} Este archivo contiene el código JavaScript que se ha desarrollado en este proyecto. Como se ha visto en el punto anterior, aquí se registra el componente de A-Frame así como todas sus funcionalidades.
	
	\item \textbf{index.html:} Este fichero es utilizado como página de ejemplo\footnote{\url{https://adrixp.github.io/aframe-charts-component/}} para mostrar la funcionalidad del componente.
	
	\item \textbf{node\_modules:} En esta carpeta se almacenan todas las dependencias del proyecto reflejadas en el archivo \textit{package.json} o aquellas que se utilicen de manera indirecta.	
	
	\item \textbf{tests:} Esta ubicación contiene los tests del proyecto. Su propósito es el de probar la funcionalidad desarrollada, mejorar la calidad del código y evitar posibles errores.
	
	\item \textbf{examples:} En esta carpeta se almacenan todos los ejemplos que se ven en el \textit{index.html}. En el siguiente apartado se describirá uno a uno cada ejemplo.
	
	\item \textbf{README.md:} Este archivo sirve para describir el funcionamiento y puesta en marcha del componente. En el se realiza una breve descripción y se pone algún ejemplo de uso para mostrar el software de un vistazo rápido.
	
	\item \textbf{.gitignore y .npmignore:} Estos ficheros se utilizan para ignorar ciertos directorios o archivos que no deben subir al repositorio de código.
\end{itemize}

\begin{figure}[H]
	\centering
	\includegraphics[width=8cm, keepaspectratio]{img/resultados-arquitectura}
	\caption{Resultados: Arquitectura Final}
	\label{fig:resultados-arquitectura}
\end{figure}

\section{Funcionamiento de la Librería} 
\label{sec:funcionamiento_libreria}

En este apartado se describe el funcionamiento de la librería. Se pondrá un ejemplo de uso y una imagen por cada gráfico y funcionalidad que soporta la librería.

\subsection{Gráfico de burbujas}

\begin{figure}[H]
	\centering
	\includegraphics[width=14cm]{img/resultados-burbujas}
	\caption{Resultados: Gráfico de burbujas}
	\label{fig:resultados-burbujas}
\end{figure}

Código para el gráfico de burbujas

\lstinputlisting[language=HTML]{code/resultados-bubble.html}

\subsection{Gráfico de barras}

\begin{figure}[H]
	\centering
	\includegraphics[width=14cm]{img/resultados-barras}
	\caption{Resultados: Gráfico de barras}
	\label{fig:resultados-barras}
\end{figure}

Código para el gráfico de barras

\lstinputlisting[language=HTML]{code/resultados-bar.html}

\subsection{Gráfico de barras cilíndricas}

\begin{figure}[H]
	\centering
	\includegraphics[width=14cm]{img/resultados-cilinder}
	\caption{Resultados: Gráfico de barras cilíndricas}
	\label{fig:resultados-cilinder}
\end{figure}

Código para el gráfico de barras cilíndricas

\lstinputlisting[language=HTML]{code/resultados-cilinder.html}

\subsection{Gráfico de tarta}

\begin{figure}[H]
	\centering
	\includegraphics[width=14cm]{img/resultados-pie}
	\caption{Resultados: Gráfico de tarta}
	\label{fig:resultados-tarta}
\end{figure}

Código para el gráfico de tarta

\lstinputlisting[language=HTML]{code/resultados-pie.html}

\subsection{Gráfico de doughnut}

\begin{figure}[H]
	\centering
	\includegraphics[width=14cm]{img/resultados-doughnut}
	\caption{Resultados: Gráfico de doughnut}
	\label{fig:resultados-donut}
\end{figure}

Código para el gráfico de doughnut

\lstinputlisting[language=HTML]{code/resultados-doughnut.html}

\subsection{Totem}

\begin{figure}[H]
	\centering
	\includegraphics[width=14cm]{img/resultados-totem}
	\caption{Resultados: Totem}
	\label{fig:resultados-totem}
\end{figure}

Código para el Totem

\lstinputlisting[language=HTML]{code/resultados-totem.html}

\subsection{Parámetros de los ejes}

\begin{figure}[H]
	\centering
	\includegraphics[width=14cm]{img/resultados-axis-param}
	\caption{Resultados: Ejemplo de ejes parametrizables}
	\label{fig:resultados-axis-param}
\end{figure}

Código para el ejemplo con ejes parametrizables

\lstinputlisting[language=HTML]{code/resultados-axis-param.html}

\subsection{Pop up}

\begin{figure}[H]
	\centering
	\includegraphics[width=14cm]{img/resultados-pop-up}
	\caption{Resultados: Gráfico con Pop-up}
	\label{fig:resultados-pop-up}
\end{figure}

Código para el gráfico que muestra un pop-up

\lstinputlisting[language=HTML]{code/resultados-pop-up.html}

\subsection{Leyenda}

\begin{figure}[H]
	\centering
	\includegraphics[width=14cm]{img/resultados-legend}
	\caption{Resultados: Gráfico con leyenda}
	\label{fig:resultados-legend}
\end{figure}

Código para el gráfico que muestra una leyenda

\lstinputlisting[language=HTML]{code/resultados-legend.html}

\subsection{LLamadas Ajax}

Ejemplo de uso con AJAX:

\lstinputlisting[language=HTML, title= Código HTML de ejemplo]{code/resultados-ajax.html}

\lstinputlisting[language=JavaScript, title= Código Ajax de ejemplo]{code/resultados-ajax.js}

\subsection{API}

\begin{table}[H]
\begin{tabular}{|l|l|l|}
	\hline
	\rowcolor[HTML]{C0C0C0} 
	Propiedad              & Descripción                                                                                                       & Valor por defecto                                                                               \\ \hline
	type                   & Tipo de gráfico                                                                                                   & bubble                                                                                          \\ \hline
	dataPoints             & Ruta al fichero JSON de entrada, asset o array de datos                                                           & ../data/data.json                                                                               \\ \hline
	axis\_position         & Posición de los ejes                                                                                              & \{x:0, y:0, z:0\}                                                                               \\ \hline
	axis\_visible          & Si es falso, no se muestran los ejes                                                                              & true                                                                                            \\ \hline
	axis\_color            & Color de los ejes                                                                                                 & red                                                                                             \\ \hline
	axis\_length           & Longitud de los ejes. Por defecto son adaptativos.                                                                & 0                                                                                               \\ \hline
	axis\_tick\_separation & Separación de los ticks de los ejes                                                                               & 1                                                                                               \\ \hline
	axis\_tick\_length     & Longitud de los ticks de los ejes                                                                                 & 0.2                                                                                             \\ \hline
	axis\_tick\_color      & Color de los ticks de los ejes                                                                                    & red                                                                                             \\ \hline
	axis\_negative         & Habilita ejes negativos.                                                                                          & true                                                                                            \\ \hline
	axis\_grid             & Habilita rejilla en los ejes                                                                                      & false                                                                                           \\ \hline
	axis\_grid\_3D         & Habilita rejilla tridimensional en los ejes                                                                       & false                                                                                           \\ \hline
	axis\_text             & Numeración de los ejes                                                                                            & true                                                                                            \\ \hline
	axis\_text\_color      & Color de la numeración de los ejes                                                                                & white                                                                                           \\ \hline
	axis\_text\_size       & Tamaño de texto de la numeración                                                                                  & 10                                                                                              \\ \hline
	pie\_radius            & Radio del gráfico de tarta                                                                                        & 1                                                                                               \\ \hline
	pie\_doughnut          & \begin{tabular}[c]{@{}l@{}}Si en vez de gráfico con forma de tarta se quiere con\\ forma de doughnut\end{tabular} & false                                                                                           \\ \hline
	show\_popup\_info      & Mostrar pop up                                                                                                    & false                                                                                           \\ \hline
	show\_legend\_info     & Mostrar leyenda                                                                                                   & false                                                                                           \\ \hline
	show\_legend\_position & Posición de la leyenda                                                                                            & \{x:0, y:0, z:0\}                                                                               \\ \hline
	show\_legend\_rotation & Rotación de la leyenda                                                                                            & \{x:0, y:0, z:0\}                                                                               \\ \hline
	show\_legend\_title    & Título de la leyenda                                                                                              & Legend                                                                                          \\ \hline
	entity\_id\_list       & Lista de identificadores separada por comas.                                                                      & barId,pieId                                                                                     \\ \hline
	dataPoints\_list       & Lista de JSON de datos.                                                                                           & \begin{tabular}[c]{@{}l@{}}\{"data1":\\  "data.json",\\ "data2":\\  "data2.json"\}\end{tabular} \\ \hline
\end{tabular}
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONCLUSIONES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Conclusiones}
\label{chap:conclusiones}


\section{Consecución de objetivos}
\label{sec:consecucion-objetivos}

El objetivo principal, alcanzado en este proyecto, ha sido el de crear una librería para la visualización de datos en 3D en un navegador web y dispositivos de realidad virtual. Por otro lado, se ha conseguido la participación de la comunidad, la cual ha pedido nuevas funcionalidades, resolución de errores e incluso utilizado esta librería en otros proyectos.

Por otra parte y de manera más específica, se ha logrado concluir con éxito varios de los objetivos previstos. Se ha conseguido proporcionar cinco tipos de visualizaciones básicas. También se ha dotado de gran versatilidad al usuario a la hora de customizar los ejes o los gráficos gracias a la gran cantidad de parámetros proporcionados.

Se ha dotado de distintas herramientas para mejorar la lectura y comprensión de los datos. Además, se ha facilitado la manera de consumir dichos datos por la librería, ya sea mediante ficheros o variables que contengan un JSON o mediante llamadas AJAX.
También se han realizado pruebas de rendimiento y control de calidad del código cumpliendo con  el objetivo de tener una librería escalable y fácilmente mantenible.
Se ha dotado de una página web con ejemplos y casos de uso. Además se han proporcionado ejemplos para el uso de esta librería en dispositivos de realidad virtual.

Por último y personalmente considerado como objetivo más importante. Se han aprendido conceptos y nuevas tecnologías en un campo apasionante y en pleno crecimiento. En los siguientes apartados se procede a describir los conocimientos aplicados y aquellos que se han aprendido con este proyecto.


\section{Aplicación de lo aprendido}
\label{sec:aplicacion}

A lo largo de la carrera, me vienen a la mente varias asignaturas protagonistas que han facilitado mucho la consecución de este proyecto. La mayoría de ellas, por razones obvias, están relacionadas con el aprendizaje y desarrollo de \textit{software}. Entre ellas, se destacan las siguientes:

\begin{itemize}
	\item \textbf{Fundamentos de la Programación}: Asignatura base donde se aprenden los conceptos básicos y los pilares fundamentales de la programación. Se aprende desde qué es un programa, hasta lo que es un algoritmo, un diagrama de flujo, variables, estructuras de control y un largo etc. Todo ello, obviamente, aplicado en la base de este proyecto.
	
	\item \textbf{Programación de Sistemas de Telecomunicación}: De esta asignatura se aplican los conceptos aprendidos sobre modularidad y encapsulación. Además se aplican los conocimientos sobre programar en diferentes niveles de una jerarquía de protocolos.
		
	\item \textbf{Sistemas Operativos}: En esta asignatura se comprende el funcionamiento de un sistema operativo así como su uso y diseño. Es otra de las asignaturas base donde se apoyan muchas de las herramientas de desarrollo utilizadas en este proyecto.
	
	\item \textbf{Procesamiento Digital de la Información}: Aquí se han obtenido conocimientos fundamentales sobre el tratamiento de la información y de los datos. Considero que es una de las asignaturas más completas de la carrera donde además se aprenden técnicas de procesamiento de datos y de \textit{machine learning} perfectamente aplicables a cualquier librería de tratamiento de datos.	
	
	\item \textbf{Servicios y Aplicaciones Telemáticas}: Asignatura clave para el proyecto donde se adquiere conocimiento de arquitecturas y protocolos de comunicación para servicios y aplicaciones Web. Se han aplicado innumerables conocimientos como uso de ficheros JSON, Gestión de HTML en el navegador, motor DOM, tecnologías AJAX, frameworks y construcción de aplicaciones.
	
	\item \textbf{Ingeniería de Sistemas de Información}: De esta asignatura se aplican conceptos como toma de requisitos, pruebas de software, mantenimiento y metodología.
\end{itemize}


\section{Lecciones aprendidas}
\label{sec:lecciones_aprendidas}

Además de los conocimientos aplicados y adquiridos durante la carrera que se mencionan en el apartado anterior, en este proyecto se han reforzado y aprendido una gran cantidad de tecnologías que hasta ahora desconocía. Entre ellas se destacan las siguientes.

\begin{enumerate}
  \item Aprender a utilizar \textit{WebPack} como empaquetador de módulos estáticos.
  
  \item Uso de \textit{NodeJS} como servidor web y \textit{npm} como gestor de paquetes y dependencias.
  
  \item Se ha aprendido el funcionamiento básico de WebGL y OpenGL. Tecnologías en las cuales se basan todas las herramientas de desarrollo 3D en el navegador.
  
  \item Descubrir y formar parte de la comunidad desarrollo de aplicaciones en 3D.
  
  \item Se ha aprendido el uso del \textit{framework} de A-Frame de manera exhaustiva, así como ThreeJS (librería en la que se basa A-Frame) de manera básica.
  
\end{enumerate}


\section{Trabajos futuros}
\label{sec:trabajos_futuros}

Siguiendo con las líneas principales marcadas en este proyecto donde se pretendía crear una librería fácilmente escalable, mantenible y sencilla de utilizar. Por tanto, siguiendo con esta filosofía se describen a continuación las líneas futuras que se propone abordar.

\begin{itemize}
	\item Integración con bases de datos no relacionales como ElasticSearch. Gracias a ello, la librería podría ser utilizada en proyectos para visualizar datos en \textit{near real time} y con grandes volúmenes de datos.
	
	\item Integración en proyectos con bases de datos relacionales tales como PostgreSQL o MySQL.
	
	\item Aumentar la customización y parametrización de los gráficos. Por ejemplo, se podrían incluir animaciones, eventos, zoom, estilos, filtrado y manipulación de los datos, etc.
	
	\item Incrementar el número de visualizaciones incluyendo alguna como de mapas de calor, gráficos de radar, gráficos de velas, etc.	
	
	\item Permitir la creación de \textit{plugins} o \textit{addons}. De esta manera se podría crear una comunidad que usase y contribuyese a la expansión de la librería.
	
	\item Facilitar la creación de \textit{dashboards}.
	
	\item Mayor empuje hacia la integración con proyectos de realidad virtual. Por ejemplo mostrar estadísticas en forma de gráfico mientras se utiliza una aplicación o se juega a algún juego en 3D. 
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BIBLIOGRAFIA %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage

% Las siguientes dos instrucciones es todo lo que necesitas
% para incluir las citas en la memoria
\bibliographystyle{abbrv}
\bibliography{memoria}  % memoria.bib es el nombre del fichero que contiene
% las referencias bibliográficas. Abre ese fichero y mira el formato que tiene,
% que se conoce como BibTeX. Hay muchos sitios que exportan referencias en
% formato BibTeX. Prueba a buscar en http://scholar.google.com por referencias
% y verás que lo puedes hacer de manera sencilla.
% Más información: 
% http://texblog.org/2014/04/22/using-google-scholar-to-download-bibtex-citations/

\end{document}
